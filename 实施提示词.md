# Aether3D PR#7 â€” Metal Rendering Pipeline: Definitive Implementation Prompt

## CRITICAL PREAMBLE â€” READ BEFORE WRITING ANY CODE

You are completing the **Metal rendering pipeline** for Aether3D's PR#7 Scan Guidance UI. The UI integration layer (HomePage, ScanView, ScanViewModel, etc.) is ALREADY COMPLETE and working. Your SOLE task is to bring the Metal shaders and GPU pipeline to life â€” transforming stubbed rendering code into a world-class **polished black metal** visual experience with ultra-smooth flip animations, specular glints, thick rounded wedge geometry, and real-time PBR lighting driven by ARKit environment data.

### What Already Exists (DO NOT recreate)

**13 files were created in the UI integration phase:**
- `App/Home/` â€” ScanRecord.swift, ScanRecordStore.swift, HomeViewModel.swift, ScanRecordCell.swift, HomePage.swift
- `App/Scan/` â€” ScanState.swift, MeshExtractor.swift, ScanViewModel.swift, ARCameraPreview.swift, ScanView.swift
- `Core/Quality/Geometry/` â€” AdjacencyProvider.swift (protocol), SpatialHashAdjacency.swift (O(n) engine)
- `Tests/ScanGuidanceTests/SpatialHashAdjacencyTests.swift` (16 test cases)

**These files are DONE. Do not modify them.** Your work is exclusively in the rendering layer.

### What You ARE Implementing

You will modify exactly **4 existing files** and create **0 new files**:

| File | Current State | Your Task |
|------|--------------|-----------|
| `App/ScanGuidance/Shaders/ScanGuidance.metal` (138 lines) | Struct definitions complete; wedgeFillFragment returns flat grayscale; borderStrokeFragment returns white; flip rotation commented out; no PBR; no ripple displacement | Full Cook-Torrance PBR, quaternion flip rotation, SDF border with AA, ripple displacement, specular glint |
| `App/ScanGuidance/ScanGuidanceRenderPipeline.swift` (210 lines) | Triple-buffered buffers allocated; createRenderPipelines() â†’ fatalError(); encodeWedgeFill/encodeBorderStroke/uploadToBuffers all empty | Load .metal library, create pipeline states, implement upload + encode functions |
| `Core/Quality/Geometry/WedgeGeometryGenerator.swift` (570 lines) | LOD0 generateFullLODWedge() falls back to LOD2 (sharp edges); LOD1/LOD2/LOD3 fully implemented | Implement real LOD0 with 2-segment bevel (44 triangles/prism) |
| `App/ScanGuidance/EvidenceRenderer.swift` (51 lines) | Empty MetalRenderView placeholder, no actual Metal rendering | Connect to ScanGuidanceRenderPipeline for Metal-backed SwiftUI view |

---

## ðŸ”´ ABSOLUTE RULES â€” VIOLATION = IMMEDIATE ROLLBACK

1. **NEVER modify any file in `Core/` EXCEPT `WedgeGeometryGenerator.swift` line 512-538 (generateFullLODWedge only)**
2. **NEVER modify `Core/Constants/ScanGuidanceConstants.swift`** â€” all 65 SSOT constants are immutable
3. **NEVER modify `App/Scan/` files** (ScanViewModel, ScanView, etc.) â€” the UI integration layer is sealed
4. **NEVER modify `App/Home/` files** â€” the homepage is sealed
5. **NEVER modify `Package.swift`** â€” App/ files are not in SwiftPM targets (intentional)
6. **NEVER modify `.github/workflows/`** â€” requires SSOT-Change commit message
7. **NEVER modify `Core/Quality/Visualization/GuidanceRenderer.swift`** â€” v2.3b sealed
8. **All constants MUST come from `ScanGuidanceConstants`** â€” zero hardcoded magic numbers
9. **All new Metal code must use `half` (FP16) for colors/normals** where possible â€” 2Ã— throughput on Apple GPUs
10. **Pre-multiplied alpha for AR overlay compositing** â€” `color.rgb *= color.a` before output

---

## WORKTREE & BRANCH

- **Worktree**: `/Users/kaidongwang/Documents/progecttwo/progect2/progect2-pr7-ui/`
- **Branch**: `pr7/scan-ui-integration` (based on `pr7/scan-guidance-ui` commit c46aa4a)
- **Do NOT touch** other worktrees: `progect2-pr7/`, `progect2-pr9/`, `progect2/`

---

## CHAPTER 1: THE VISUAL VISION â€” What the User Wants

The user described their desired rendering in these exact words (translated):

> "I need ultra-smooth flip animation experience, metallic luster, thick rounded triangles with real thickness, and that reflective glint during each flip â€” like real black metal."

This translates to five specific rendering requirements:

### 1.1 Polished Black Metal Surface
- **Look**: Deep black with bright specular highlights that shift as the camera moves â€” like polished obsidian or gun metal
- **Material**: Metalness = 1.0 (fully metallic), Roughness = 0.05â€“0.15 (mirror-like), Base albedo â‰ˆ (0.02, 0.02, 0.02)
- **At low coverage (display < 0.75)**: Matte dark metal â€” roughness 0.6, metalness 0.3
- **At high coverage (display â‰¥ 0.75)**: Polished metal â€” roughness 0.3, metalness 0.7
- **The SSOT constants already encode this**: `metallicBase=0.3`, `metallicS3Bonus=0.4`, `roughnessBase=0.6`, `roughnessS3Reduction=0.3`

### 1.2 Ultra-Smooth Flip Animation
- Triangle physically rotates 180Â° around its longest edge when crossing a coverage threshold (S0â†’S1 at 0.10, S1â†’S2 at 0.25, etc.)
- Cubic Bezier easing with overshoot: CP1=(0.34, 1.56), CP2=(0.64, 1.0) â€” the triangle overshoots ~10% past 180Â° then settles back
- Duration: 0.5 seconds per flip
- Adjacent triangles stagger by 30ms for a wave-like cascade effect
- **The FlipAnimationController already computes per-triangle flipAngle [0, Ï€] and axis data** â€” the shader just needs to rotate vertices

### 1.3 Specular Glint During Rotation
- As a triangle rotates, its normal sweeps through different angles relative to the camera and light
- At certain angles during rotation, the GGX specular lobe will naturally produce a bright "flash" or "glint"
- With roughness 0.05â€“0.15, this is automatic from the Cook-Torrance BRDF â€” no special code needed
- The glint is most visible when the reflected light direction aligns with the view direction during mid-rotation

### 1.4 Thick Rounded Wedge Geometry
- Each triangle is extruded into a 3D wedge (prism) with visible thickness
- Thickness decays with coverage: `base Ã— (1 - display)^0.7 Ã— sqrt(area/median)`, clamped to [0.5mm, 8mm]
- LOD0: 2-segment bevel on all edges for smooth rounded appearance (44 triangles per prism)
- The bevel creates continuous normal variation across edges, producing smooth specular highlights instead of hard edges

### 1.5 BFS Ripple Displacement
- When a flip triggers, a ripple wave propagates outward via BFS on the mesh adjacency graph
- Each triangle in the ripple's path oscillates along its normal (cosine envelope Ã— exponential decay)
- Visual effect: a shimmering wave of displacement spreading from the flip origin
- **RipplePropagationEngine already computes per-triangle amplitude [0, 1]** â€” shader multiplies by thickness for vertex displacement

---

## CHAPTER 2: EXISTING INFRASTRUCTURE AUDIT â€” What Each File Provides

### 2.1 ScanGuidance.metal (Current: 138 lines)

**KEEP these structs EXACTLY as-is:**

```metal
struct WedgeVertex {
    float3 position     [[attribute(0)]];  // World-space position
    float3 normal       [[attribute(1)]];  // World-space normal
    float  metallic     [[attribute(2)]];  // [0, 1] metalness
    float  roughness    [[attribute(3)]];  // [0, 1] roughness
    float  display      [[attribute(4)]];  // [0, 1] coverage display value
    float  thickness    [[attribute(5)]];  // Meters, for ripple displacement scale
    uint   triangleId   [[attribute(6)]];  // Index into PerTriangleData buffer
};

struct ScanGuidanceUniforms {
    float4x4 viewProjectionMatrix;
    float4x4 modelMatrix;
    float3   cameraPosition;
    float3   primaryLightDirection;
    float    primaryLightIntensity;
    float3   shCoeffs[9];  // L2 Spherical Harmonics (9 Ã— RGB)
    uint     qualityTier;  // 0=nominal, 1=fair, 2=serious, 3=critical
    float    time;         // Elapsed seconds (for animation)
    float    borderGamma;  // Stevens' Power Law gamma (1.4)
};

struct PerTriangleData {
    float  flipAngle;         // [0, Ï€] rotation angle from FlipAnimationController
    float  rippleAmplitude;   // [0, 1] from RipplePropagationEngine
    float  borderWidth;       // Pixels, from AdaptiveBorderCalculator
    float3 flipAxisOrigin;    // Rotation axis origin (longest edge start)
    float3 flipAxisDirection; // Rotation axis direction (normalized)
    float3 grayscaleColor;    // RGB [0,1] from GrayscaleMapper
};

struct VertexOut {
    float4 position [[position]];
    float3 worldNormal;
    float3 worldPosition;
    float  metallic;
    float  roughness;
    float  display;
    float  rippleAmplitude;
    float3 grayscaleColor;
    float  borderWidth;
};
```

**KEEP the SDF helper functions** (`sdTriangle2D`, `sdRoundedTriangle`) â€” they will be used by borderStrokeFragment.

### 2.2 ScanGuidanceRenderPipeline.swift (Current: 210 lines)

**What's already working:**
- `device`, `commandQueue` initialization âœ“
- Triple-buffered `vertexBuffers[3]` (1MB), `uniformBuffers[3]` (1KB), `perTriangleBuffers[3]` (64KB) âœ“
- `inflightSemaphore` with `DispatchSemaphore(value: 3)` âœ“
- `encode()` method structure: semaphore wait â†’ get buffer index â†’ create render encoder â†’ encode passes â†’ end encoding âœ“
- `update()` method: calls wedgeGenerator, lightEstimator, flipController, rippleEngine, borderCalculator, thermalAdapter â€” all correct âœ“
- All sub-system instances (wedgeGenerator, flipController, etc.) âœ“

**What's stubbed (YOUR task):**
- `createRenderPipelines()` â†’ `fatalError()` at line 176
- `encodeWedgeFill()` â†’ empty at line 179
- `encodeBorderStroke()` â†’ empty at line 184
- `uploadToBuffers()` â†’ empty at line 189

### 2.3 WedgeGeometryGenerator.swift (Current: 570 lines)

**What's fully implemented:**
- `WedgeVertexData` and `WedgeVertexCPU` structs âœ“
- `LODLevel` enum (.full, .medium, .low, .flat) âœ“
- `generateFlatWedge()` â€” LOD3, 3 vertices, 1 triangle âœ“
- `generateLowLODWedge()` â€” LOD2, 6 vertices, 8 triangles (sharp edges) âœ“
- `generateMediumLODWedge()` â€” LOD1, 42 vertices, 26 triangles (1-segment bevel) âœ“
- `thickness()` â€” display-dependent thickness with area normalization âœ“
- `bevelNormals()` â€” interpolated normals for smooth bevel transitions âœ“

**What's stubbed (YOUR task):**
- `generateFullLODWedge()` at line 512 â€” currently delegates to `generateLowLODWedge()` (sharp edges instead of 2-segment bevel)

### 2.4 ScanGuidanceVertexDescriptor.swift (COMPLETE â€” DO NOT MODIFY)

Vertex layout: 7 attributes, stride = 44 bytes
- Attribute 0: position (float3) at offset 0
- Attribute 1: normal (float3) at offset 12
- Attribute 2: metallic (float) at offset 24
- Attribute 3: roughness (float) at offset 28
- Attribute 4: display (float) at offset 32
- Attribute 5: thickness (float) at offset 36
- Attribute 6: triangleId (uint) at offset 40

Buffer indices: vertexData=0, uniforms=1, perTriangleData=2

### 2.5 EnvironmentLightEstimator.swift (COMPLETE â€” DO NOT MODIFY)

Returns `LightState` with:
- `direction: SIMD3<Float>` â€” primary light direction
- `intensity: Float` â€” ambient intensity (ARKit lux value, typically 200â€“2000)
- `shCoeffs: [SIMD3<Float>]` â€” 9 L2 Spherical Harmonics coefficients (RGB)
- `tier: EstimationTier` â€” .arkit / .vision / .fallback

The SH coefficients are extracted from `ARLightEstimate.sphericalHarmonicsCoefficients` (27 floats â†’ 9 Ã— RGB). These are passed directly to the uniform buffer as `uniforms.shCoeffs[9]`.

### 2.6 Key SSOT Constants (from ScanGuidanceConstants.swift)

**Material:**
| Constant | Value | Usage |
|----------|-------|-------|
| `metallicBase` | 0.3 | Default metalness for display < 0.75 |
| `metallicS3Bonus` | 0.4 | Added at display â‰¥ 0.75 â†’ total 0.7 |
| `roughnessBase` | 0.6 | Default roughness for display < 0.75 |
| `roughnessS3Reduction` | 0.3 | Subtracted at display â‰¥ 0.75 â†’ total 0.3 |
| `fresnelF0` | 0.04 | Dielectric Fresnel reflectance |
| `fresnelF0Metallic` | 0.7 | Metallic Fresnel reflectance |

**Flip Animation:**
| Constant | Value | Usage |
|----------|-------|-------|
| `flipDurationS` | 0.5 | Animation duration in seconds |
| `flipEasingCP1Y` | 1.56 | Overshoot control point |
| `flipMaxConcurrent` | 20 | Max simultaneous flips |
| `flipStaggerDelayS` | 0.03 | Cascade delay between adjacent triangles |

**Ripple:**
| Constant | Value | Usage |
|----------|-------|-------|
| `rippleDelayPerHopS` | 0.06 | BFS propagation speed |
| `rippleMaxHops` | 8 | Maximum propagation distance |
| `rippleDampingPerHop` | 0.85 | Amplitude decay factor per hop |
| `rippleThicknessMultiplier` | 0.3 | Displacement = amplitude Ã— thickness Ã— this |

**Border:**
| Constant | Value | Usage |
|----------|-------|-------|
| `borderBaseWidthPx` | 6.0 | Base border width in pixels |
| `borderGamma` | 1.4 | Stevens' Power Law gamma |
| `borderAlphaAtS0` | 1.0 | Full opacity at zero coverage |

**Wedge Geometry:**
| Constant | Value | Usage |
|----------|-------|-------|
| `bevelSegmentsLOD0` | 2 | Number of bevel subdivisions for LOD0 |
| `bevelRadiusRatio` | 0.15 | Bevel radius as fraction of thickness |
| `lod0TrianglesPerPrism` | 44 | Expected triangle count for LOD0 |

**Performance:**
| Constant | Value | Usage |
|----------|-------|-------|
| `kMaxInflightBuffers` | 3 | Triple-buffered rendering |

---

## CHAPTER 3: METAL SHADER IMPLEMENTATION â€” ScanGuidance.metal

### 3.1 Overview of Render Passes

The final .metal file will have exactly **2 render passes** (not 3 â€” the "metallic lighting" is integrated into Pass 1):

1. **Pass 1: Wedge Fill** â€” PBR-lit wedge geometry with flip rotation + ripple displacement
2. **Pass 2: Border Stroke** â€” SDF-based anti-aliased border lines on triangle edges

### 3.2 Cook-Torrance PBR Functions

Add the following PBR helper functions ABOVE the vertex/fragment shaders. Use `half` precision for all intermediate lighting calculations:

```metal
// â”€â”€â”€ PBR Helper Functions â”€â”€â”€

// GGX/Trowbridge-Reitz Normal Distribution Function
// Concentration of microfacets aligned with halfway vector
inline half NDF_GGX(half NdotH, half roughness) {
    half a = roughness * roughness;
    half a2 = a * a;
    half NdotH2 = NdotH * NdotH;
    half denom = NdotH2 * (a2 - 1.0h) + 1.0h;
    denom = M_PI_H * denom * denom;
    return a2 / max(denom, 1e-7h);
}

// Schlick-GGX Geometry sub-function
// Microfacet self-shadowing for a single direction
inline half GeometrySchlickGGX(half NdotV, half roughness) {
    half r = roughness + 1.0h;
    half k = (r * r) / 8.0h;
    return NdotV / (NdotV * (1.0h - k) + k);
}

// Smith's Geometry Function (combines view + light shadowing)
inline half GeometrySmith(half NdotV, half NdotL, half roughness) {
    return GeometrySchlickGGX(NdotV, roughness) * GeometrySchlickGGX(NdotL, roughness);
}

// Schlick Fresnel Approximation
// F0 = base reflectance at normal incidence
inline half3 FresnelSchlick(half cosTheta, half3 F0) {
    half t = 1.0h - cosTheta;
    half t2 = t * t;
    half t5 = t2 * t2 * t;
    return F0 + (1.0h - F0) * t5;
}

// Evaluate L2 Spherical Harmonics (9 coefficients)
// Input: normal direction (normalized), SH coefficients (9 Ã— RGB as float3)
// Output: irradiance RGB
inline half3 evaluateSH(float3 n, constant float3 *shCoeffs) {
    // L0 band (ambient)
    half3 result = half3(shCoeffs[0]) * 0.282095h;

    // L1 band (directional)
    result += half3(shCoeffs[1]) * 0.488603h * half(n.y);
    result += half3(shCoeffs[2]) * 0.488603h * half(n.z);
    result += half3(shCoeffs[3]) * 0.488603h * half(n.x);

    // L2 band (detailed directional)
    result += half3(shCoeffs[4]) * 1.092548h * half(n.x * n.y);
    result += half3(shCoeffs[5]) * 1.092548h * half(n.y * n.z);
    result += half3(shCoeffs[6]) * 0.315392h * half(3.0 * n.z * n.z - 1.0);
    result += half3(shCoeffs[7]) * 1.092548h * half(n.x * n.z);
    result += half3(shCoeffs[8]) * 0.546274h * half(n.x * n.x - n.y * n.y);

    return max(result, 0.0h);
}

// Quaternion from axis-angle (for flip rotation)
// Returns quaternion as float4(xyz = imaginary, w = real)
inline float4 quatFromAxisAngle(float3 axis, float angle) {
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    float c = cos(halfAngle);
    return float4(axis * s, c);
}

// Rotate vector by quaternion
// q must be unit quaternion
inline float3 rotateByQuat(float3 v, float4 q) {
    float3 u = q.xyz;
    float w = q.w;
    return 2.0 * dot(u, v) * u
         + (w * w - dot(u, u)) * v
         + 2.0 * w * cross(u, v);
}
```

### 3.3 Wedge Fill Vertex Shader â€” Full Implementation

Replace the current `wedgeFillVertex` function entirely. Key changes:
1. **Quaternion flip rotation** around the triangle's longest edge
2. **Ripple displacement** along the normal, scaled by amplitude Ã— thickness Ã— multiplier
3. **Normal rotation** matching the vertex rotation (so lighting stays correct during flips)

```metal
vertex VertexOut wedgeFillVertex(
    WedgeVertex in [[stage_in]],
    constant ScanGuidanceUniforms &uniforms [[buffer(1)]],
    constant PerTriangleData *triData [[buffer(2)]],
    uint vid [[vertex_id]]
) {
    VertexOut out;
    uint triId = in.triangleId;

    float3 pos = in.position;
    float3 norm = in.normal;

    // â”€â”€ Step 1: Flip Rotation â”€â”€
    // flipAngle is [0, Ï€] computed by FlipAnimationController with cubic bezier overshoot
    float angle = triData[triId].flipAngle;
    if (angle > 0.001) {
        float3 axisOrigin = triData[triId].flipAxisOrigin;
        float3 axisDir = triData[triId].flipAxisDirection;

        // Translate to axis-local space, rotate, translate back
        float3 localPos = pos - axisOrigin;
        float4 q = quatFromAxisAngle(axisDir, angle);
        localPos = rotateByQuat(localPos, q);
        pos = localPos + axisOrigin;

        // Rotate normal too (critical for correct specular during flip)
        norm = rotateByQuat(norm, q);
    }

    // â”€â”€ Step 2: Ripple Displacement â”€â”€
    // Displace vertex along normal by rippleAmplitude Ã— thickness Ã— multiplier
    // rippleThicknessMultiplier = 0.3 (from SSOT constants, passed via uniform or hardcoded
    // since this is a compile-time constant for the shader)
    float ripple = triData[triId].rippleAmplitude;
    if (ripple > 0.001) {
        float displacement = ripple * in.thickness * 0.3;  // rippleThicknessMultiplier
        pos += norm * displacement;
    }

    // â”€â”€ Step 3: Transform to clip space â”€â”€
    float4 worldPos = uniforms.modelMatrix * float4(pos, 1.0);
    out.position = uniforms.viewProjectionMatrix * worldPos;
    out.worldPosition = worldPos.xyz;
    out.worldNormal = normalize((uniforms.modelMatrix * float4(norm, 0.0)).xyz);

    // â”€â”€ Step 4: Pass-through attributes â”€â”€
    out.metallic = in.metallic;
    out.roughness = in.roughness;
    out.display = in.display;
    out.rippleAmplitude = ripple;
    out.grayscaleColor = triData[triId].grayscaleColor;
    out.borderWidth = triData[triId].borderWidth;

    return out;
}
```

### 3.4 Wedge Fill Fragment Shader â€” Full Cook-Torrance PBR

Replace the current `wedgeFillFragment` function entirely. This is the heart of the rendering.

```metal
fragment half4 wedgeFillFragment(
    VertexOut in [[stage_in]],
    constant ScanGuidanceUniforms &uniforms [[buffer(1)]]
) {
    // â”€â”€ Material Properties â”€â”€
    half metallic = half(in.metallic);
    half roughness = half(in.roughness);

    // Base color: grayscale mapped by coverage, tinted slightly for metal
    half3 baseColor = half3(in.grayscaleColor);

    // For metallic surfaces, F0 = base color (colored reflections)
    // For dielectric, F0 = 0.04 (constant)
    half3 F0 = mix(half3(0.04h), baseColor, metallic);

    // â”€â”€ Vectors â”€â”€
    float3 N = normalize(in.worldNormal);
    float3 V = normalize(uniforms.cameraPosition - in.worldPosition);
    float3 L = normalize(-uniforms.primaryLightDirection);  // Light direction toward surface
    float3 H = normalize(V + L);

    half NdotL = half(max(dot(N, L), 0.0));
    half NdotV = half(max(dot(N, V), 0.001));  // Avoid division by zero
    half NdotH = half(max(dot(N, H), 0.0));
    half HdotV = half(max(dot(H, V), 0.0));

    // â”€â”€ Cook-Torrance Specular BRDF â”€â”€
    half D = NDF_GGX(NdotH, roughness);
    half G = GeometrySmith(NdotV, NdotL, roughness);
    half3 F = FresnelSchlick(HdotV, F0);

    half3 numerator = D * G * F;
    half denominator = 4.0h * NdotV * NdotL + 0.0001h;
    half3 specular = numerator / denominator;

    // â”€â”€ Energy Conservation â”€â”€
    half3 kS = F;  // Specular contribution
    half3 kD = (1.0h - kS) * (1.0h - metallic);  // Diffuse only for dielectrics

    // â”€â”€ Diffuse: Lambertian â”€â”€
    half3 diffuse = kD * baseColor / M_PI_H;

    // â”€â”€ Direct Lighting â”€â”€
    half lightIntensity = half(uniforms.primaryLightIntensity);
    // Normalize ARKit lux to reasonable range (1000 lux = 1.0)
    half normalizedIntensity = clamp(lightIntensity / 1000.0h, 0.1h, 3.0h);
    half3 directLight = (diffuse + specular) * NdotL * normalizedIntensity;

    // â”€â”€ Indirect Lighting (SH-based IBL) â”€â”€
    half3 irradiance = evaluateSH(N, uniforms.shCoeffs);
    // Normalize SH irradiance (ARKit SH can be very bright)
    irradiance = irradiance / max(half3(uniforms.shCoeffs[0]) * 0.282095h, 0.01h) * 0.3h;
    half3 indirectDiffuse = kD * baseColor * irradiance;

    // Indirect specular: approximate with SH evaluated at reflection direction
    float3 R = reflect(-V, N);
    half3 reflectedIrradiance = evaluateSH(R, uniforms.shCoeffs);
    reflectedIrradiance = reflectedIrradiance / max(half3(uniforms.shCoeffs[0]) * 0.282095h, 0.01h) * 0.5h;
    // Rough surfaces get less indirect specular
    half3 indirectSpecular = F0 * reflectedIrradiance * (1.0h - roughness * 0.7h);

    half3 indirect = indirectDiffuse + indirectSpecular;

    // â”€â”€ Combine â”€â”€
    half3 color = directLight + indirect;

    // â”€â”€ Ambient minimum (prevent pure black in dark environments) â”€â”€
    color = max(color, baseColor * 0.02h);

    // â”€â”€ Ripple highlight: subtle brightness boost during ripple â”€â”€
    if (in.rippleAmplitude > 0.001) {
        half rippleBoost = half(in.rippleAmplitude) * 0.15h;
        color += rippleBoost;
    }

    // â”€â”€ Tone mapping (simple Reinhard) â”€â”€
    color = color / (color + 1.0h);

    // â”€â”€ Alpha: opaque for visible triangles, fade at S5 â”€â”€
    half alpha = 1.0h;
    if (in.display > 0.88h) {  // s4ToS5Threshold
        // Fade out at S5
        alpha = 1.0h - (half(in.display) - 0.88h) / (1.0h - 0.88h);
        alpha = clamp(alpha, 0.0h, 1.0h);
    }

    // Pre-multiplied alpha for correct AR compositing
    color *= alpha;

    return half4(color, alpha);
}
```

### 3.5 Border Stroke Fragment Shader â€” SDF with Anti-Aliasing

Replace the current `borderStrokeFragment`. Uses the EXISTING `sdTriangle2D` and `sdRoundedTriangle` helper functions:

```metal
fragment half4 borderStrokeFragment(
    VertexOut in [[stage_in]],
    constant ScanGuidanceUniforms &uniforms [[buffer(1)]]
) {
    // Border width from AdaptiveBorderCalculator (Stevens' Power Law weighted)
    half borderWidth = half(in.borderWidth);

    // Skip if border width is effectively zero
    if (borderWidth < 0.5h) {
        discard_fragment();
    }

    // Border color: bright white for contrast against dark metal
    half3 borderColor = half3(1.0h, 1.0h, 1.0h);

    // Alpha: modulated by display value (more opaque at low coverage)
    half baseAlpha = half(1.0);  // borderAlphaAtS0
    half displayFade = 1.0h - half(in.display) * 0.5h;  // Fade with coverage
    half alpha = baseAlpha * displayFade;

    // Apply Stevens' Power Law gamma correction for perceptual uniformity
    half gamma = half(uniforms.borderGamma);  // 1.4
    alpha = pow(alpha, 1.0h / gamma);

    // Anti-aliasing: smooth edge based on screen-space derivatives
    // Use fwidth for screen-space pixel width estimation
    half edgeSoftness = half(fwidth(in.position.x) + fwidth(in.position.y)) * 0.5h;
    alpha *= smoothstep(0.0h, edgeSoftness * 2.0h, borderWidth * 0.1h);

    // Pre-multiplied alpha
    borderColor *= alpha;

    return half4(borderColor, alpha);
}
```

### 3.6 Quality Policy in Shader

**No quality tier branching in the fragment shader.** Always execute the full PBR pipeline:

```metal
    // ALWAYS full PBR â€” no quality degradation, ever.
    // qualityTier uniform exists for telemetry only, NOT for rendering decisions.
    // Every user gets maximum quality regardless of thermal state.
```

The `qualityTier` uniform is populated by ThermalQualityAdapter for **logging/analytics purposes only**. The shader never reads it for branching. This ensures every frame gets full Cook-Torrance + clearcoat + anisotropic + SH lighting.

### 3.7 Complete Metal File Structure

The final `ScanGuidance.metal` file should be structured as:

```
1.  Header comment
2.  #include <metal_stdlib>
3.  using namespace metal;
4.
5.  // â”€â”€â”€ Structs â”€â”€â”€ (UNCHANGED from current)
6.  WedgeVertex, ScanGuidanceUniforms, PerTriangleData, VertexOut
7.
8.  // â”€â”€â”€ PBR Helper Functions â”€â”€â”€
9.  NDF_GGX, GeometrySchlickGGX, GeometrySmith, FresnelSchlick, evaluateSH
10. quatFromAxisAngle, rotateByQuat
11.
12. // â”€â”€â”€ Pass 1: Wedge Fill â”€â”€â”€
13. wedgeFillVertex (with flip rotation + ripple displacement)
14. wedgeFillFragment (with Cook-Torrance PBR + SH lighting)
15.
16. // â”€â”€â”€ Pass 2: Border Stroke â”€â”€â”€
17. sdTriangle2D (UNCHANGED)
18. sdRoundedTriangle (UNCHANGED)
19. borderStrokeFragment (with SDF AA + adaptive width)
```

Expected line count: ~280-320 lines total.

---

## CHAPTER 4: RENDER PIPELINE IMPLEMENTATION â€” ScanGuidanceRenderPipeline.swift

### 4.1 createRenderPipelines() â€” Replace fatalError()

Replace the entire `createRenderPipelines()` method:

```swift
private func createRenderPipelines() throws {
    // Load Metal library from the app bundle
    guard let library = device.makeDefaultLibrary() else {
        throw ScanGuidanceError.pipelineCreationFailed("Failed to load Metal library")
    }

    // â”€â”€ Pass 1: Wedge Fill Pipeline â”€â”€
    guard let wedgeVertexFn = library.makeFunction(name: "wedgeFillVertex"),
          let wedgeFragmentFn = library.makeFunction(name: "wedgeFillFragment") else {
        throw ScanGuidanceError.pipelineCreationFailed("Failed to load wedge fill shaders")
    }

    let wedgeDescriptor = MTLRenderPipelineDescriptor()
    wedgeDescriptor.label = "Aether3D Wedge Fill"
    wedgeDescriptor.vertexFunction = wedgeVertexFn
    wedgeDescriptor.fragmentFunction = wedgeFragmentFn
    wedgeDescriptor.vertexDescriptor = ScanGuidanceVertexDescriptor.create()

    // Color attachment: pre-multiplied alpha blending for AR overlay
    wedgeDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm
    wedgeDescriptor.colorAttachments[0].isBlendingEnabled = true
    wedgeDescriptor.colorAttachments[0].sourceRGBBlendFactor = .one  // pre-multiplied
    wedgeDescriptor.colorAttachments[0].destinationRGBBlendFactor = .oneMinusSourceAlpha
    wedgeDescriptor.colorAttachments[0].sourceAlphaBlendFactor = .one
    wedgeDescriptor.colorAttachments[0].destinationAlphaBlendFactor = .oneMinusSourceAlpha

    // Depth
    wedgeDescriptor.depthAttachmentPixelFormat = .depth32Float

    wedgeFillPipeline = try device.makeRenderPipelineState(descriptor: wedgeDescriptor)

    // â”€â”€ Pass 2: Border Stroke Pipeline â”€â”€
    // Reuse wedge fill vertex shader (same vertex layout)
    guard let borderFragmentFn = library.makeFunction(name: "borderStrokeFragment") else {
        throw ScanGuidanceError.pipelineCreationFailed("Failed to load border stroke shader")
    }

    let borderDescriptor = MTLRenderPipelineDescriptor()
    borderDescriptor.label = "Aether3D Border Stroke"
    borderDescriptor.vertexFunction = wedgeVertexFn  // Same vertex shader
    borderDescriptor.fragmentFunction = borderFragmentFn
    borderDescriptor.vertexDescriptor = ScanGuidanceVertexDescriptor.create()

    // Additive blending for borders (overlay on top of wedge fill)
    borderDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm
    borderDescriptor.colorAttachments[0].isBlendingEnabled = true
    borderDescriptor.colorAttachments[0].sourceRGBBlendFactor = .one  // pre-multiplied
    borderDescriptor.colorAttachments[0].destinationRGBBlendFactor = .oneMinusSourceAlpha
    borderDescriptor.colorAttachments[0].sourceAlphaBlendFactor = .one
    borderDescriptor.colorAttachments[0].destinationAlphaBlendFactor = .oneMinusSourceAlpha

    borderDescriptor.depthAttachmentPixelFormat = .depth32Float

    borderStrokePipeline = try device.makeRenderPipelineState(descriptor: borderDescriptor)
}
```

### 4.2 uploadToBuffers() â€” Populate Triple-Buffered GPU Data

Replace the empty `uploadToBuffers()` method. This is the CPUâ†’GPU data bridge:

```swift
private func uploadToBuffers(
    wedgeData: WedgeVertexData,
    lightState: EnvironmentLightEstimator.LightState,
    flipAngles: [Float],
    rippleAmplitudes: [Float],
    borderWidths: [Float],
    cameraTransform: simd_float4x4,
    qualityTier: Int
) {
    let bufferIndex = currentBufferIndex

    // â”€â”€ Vertex Buffer â”€â”€
    // WedgeVertexCPU layout must match WedgeVertex in .metal (44 bytes stride)
    let vertexCount = wedgeData.vertices.count
    let requiredVertexSize = vertexCount * MemoryLayout<Float>.size * 10 + vertexCount * MemoryLayout<UInt32>.size

    // Grow buffer if needed
    if requiredVertexSize > vertexBuffers[bufferIndex].length {
        let newSize = max(requiredVertexSize, vertexBuffers[bufferIndex].length * 2)
        if let newBuffer = device.makeBuffer(length: newSize, options: []) {
            vertexBuffers[bufferIndex] = newBuffer
        }
    }

    // Copy vertex data â€” WedgeVertexCPU is already laid out to match the Metal struct
    let vertexPtr = vertexBuffers[bufferIndex].contents()
    let stride = MemoryLayout<Float>.size * 10 + MemoryLayout<UInt32>.size  // 44 bytes
    for (i, vertex) in wedgeData.vertices.enumerated() {
        let base = vertexPtr + i * stride
        base.storeBytes(of: vertex.position.x, as: Float.self)
        (base + 4).storeBytes(of: vertex.position.y, as: Float.self)
        (base + 8).storeBytes(of: vertex.position.z, as: Float.self)
        (base + 12).storeBytes(of: vertex.normal.x, as: Float.self)
        (base + 16).storeBytes(of: vertex.normal.y, as: Float.self)
        (base + 20).storeBytes(of: vertex.normal.z, as: Float.self)
        (base + 24).storeBytes(of: vertex.metallic, as: Float.self)
        (base + 28).storeBytes(of: vertex.roughness, as: Float.self)
        (base + 32).storeBytes(of: vertex.display, as: Float.self)
        (base + 36).storeBytes(of: vertex.thickness, as: Float.self)
        (base + 40).storeBytes(of: vertex.triangleId, as: UInt32.self)
    }

    // â”€â”€ Uniform Buffer â”€â”€
    // Build ScanGuidanceUniforms struct
    struct GPUUniforms {
        var viewProjectionMatrix: simd_float4x4
        var modelMatrix: simd_float4x4
        var cameraPosition: SIMD3<Float>
        var _pad0: Float = 0  // Alignment padding
        var primaryLightDirection: SIMD3<Float>
        var primaryLightIntensity: Float
        var shCoeffs: (SIMD3<Float>, SIMD3<Float>, SIMD3<Float>, SIMD3<Float>, SIMD3<Float>,
                       SIMD3<Float>, SIMD3<Float>, SIMD3<Float>, SIMD3<Float>)
        var qualityTier: UInt32
        var time: Float
        var borderGamma: Float
        var _pad1: Float = 0  // Alignment padding
    }

    // Extract camera position from transform (4th column)
    let camPos = SIMD3<Float>(cameraTransform.columns.3.x,
                               cameraTransform.columns.3.y,
                               cameraTransform.columns.3.z)

    // Build SH coefficients tuple from array
    let sh = lightState.shCoeffs
    let shTuple = (
        sh.count > 0 ? sh[0] : SIMD3<Float>(0,0,0),
        sh.count > 1 ? sh[1] : SIMD3<Float>(0,0,0),
        sh.count > 2 ? sh[2] : SIMD3<Float>(0,0,0),
        sh.count > 3 ? sh[3] : SIMD3<Float>(0,0,0),
        sh.count > 4 ? sh[4] : SIMD3<Float>(0,0,0),
        sh.count > 5 ? sh[5] : SIMD3<Float>(0,0,0),
        sh.count > 6 ? sh[6] : SIMD3<Float>(0,0,0),
        sh.count > 7 ? sh[7] : SIMD3<Float>(0,0,0),
        sh.count > 8 ? sh[8] : SIMD3<Float>(0,0,0)
    )

    var uniforms = GPUUniforms(
        viewProjectionMatrix: cameraTransform,  // Caller provides VP matrix
        modelMatrix: matrix_identity_float4x4,   // Mesh is in world space
        cameraPosition: camPos,
        primaryLightDirection: lightState.direction,
        primaryLightIntensity: lightState.intensity,
        shCoeffs: shTuple,
        qualityTier: UInt32(qualityTier),
        time: Float(CACurrentMediaTime()),
        borderGamma: Float(ScanGuidanceConstants.borderGamma)
    )

    memcpy(uniformBuffers[bufferIndex].contents(), &uniforms, MemoryLayout<GPUUniforms>.size)

    // â”€â”€ Per-Triangle Data Buffer â”€â”€
    let triCount = wedgeData.triangleCount
    let perTriSize = MemoryLayout<Float>.size * 15  // 3+1+1+3+3+3 = 15 floats per triangle?
    // Actually: flipAngle(1) + rippleAmplitude(1) + borderWidth(1) + flipAxisOrigin(3) + flipAxisDirection(3) + grayscaleColor(3) = 12 floats = 48 bytes
    let perTriStride = 48  // 12 floats
    let requiredPerTriSize = triCount * perTriStride

    if requiredPerTriSize > perTriangleBuffers[bufferIndex].length {
        let newSize = max(requiredPerTriSize, perTriangleBuffers[bufferIndex].length * 2)
        if let newBuffer = device.makeBuffer(length: newSize, options: []) {
            perTriangleBuffers[bufferIndex] = newBuffer
        }
    }

    let triPtr = perTriangleBuffers[bufferIndex].contents()
    for i in 0..<triCount {
        let base = triPtr + i * perTriStride

        // flipAngle
        let flipAngle: Float = i < flipAngles.count ? flipAngles[i] : 0.0
        base.storeBytes(of: flipAngle, as: Float.self)

        // rippleAmplitude
        let rippleAmp: Float = i < rippleAmplitudes.count ? rippleAmplitudes[i] : 0.0
        (base + 4).storeBytes(of: rippleAmp, as: Float.self)

        // borderWidth
        let bw: Float = i < borderWidths.count ? borderWidths[i] : 0.0
        (base + 8).storeBytes(of: bw, as: Float.self)

        // flipAxisOrigin (3 floats)
        // These come from FlipAnimationController.getFlipAxis(for:)
        // For now, use zero â€” ScanViewModel populates these via the controller
        (base + 12).storeBytes(of: Float(0), as: Float.self)
        (base + 16).storeBytes(of: Float(0), as: Float.self)
        (base + 20).storeBytes(of: Float(0), as: Float.self)

        // flipAxisDirection (3 floats)
        (base + 24).storeBytes(of: Float(1), as: Float.self)  // Default X axis
        (base + 28).storeBytes(of: Float(0), as: Float.self)
        (base + 32).storeBytes(of: Float(0), as: Float.self)

        // grayscaleColor (3 floats)
        (base + 36).storeBytes(of: Float(0.5), as: Float.self)  // Default mid-gray
        (base + 40).storeBytes(of: Float(0.5), as: Float.self)
        (base + 44).storeBytes(of: Float(0.5), as: Float.self)
    }
}
```

**IMPORTANT NOTE**: The `uploadToBuffers()` implementation above is a starting point. The actual per-triangle data (flipAxisOrigin, flipAxisDirection, grayscaleColor) must come from the caller's computed data. The `update()` method in ScanGuidanceRenderPipeline already computes `flipAngles`, `rippleAmplitudes`, `borderWidths`, and `wedgeData` â€” but it does NOT yet extract per-triangle flip axis data from `FlipAnimationController.getFlipAxis(for:)` or grayscale colors from `GrayscaleMapper.grayscale(for:)`.

**You MUST extend `uploadToBuffers()`** to accept additional parameters:
- `flipAxisData: [(origin: SIMD3<Float>, direction: SIMD3<Float>)]` â€” from FlipAnimationController
- `grayscaleColors: [(Float, Float, Float)]` â€” from GrayscaleMapper

And the `update()` method must compute these before calling `uploadToBuffers()`. Add them to the `update()` method:

```swift
// Inside update(), before calling uploadToBuffers():

// Compute per-triangle flip axis data
var flipAxisData: [(origin: SIMD3<Float>, direction: SIMD3<Float>)] = []
for i in 0..<limitedTriangles.count {
    if let axis = flipController.getFlipAxis(for: i) {
        flipAxisData.append(axis)
    } else {
        flipAxisData.append((SIMD3<Float>(0,0,0), SIMD3<Float>(1,0,0)))
    }
}

// Compute per-triangle grayscale colors
var grayscaleColors: [(Float, Float, Float)] = []
for triangle in limitedTriangles {
    let display = displaySnapshot[triangle.patchId] ?? 0.0
    let (r, g, b) = grayscaleMapper.grayscale(for: display)
    grayscaleColors.append((r, g, b))
}
```

### 4.3 encodeWedgeFill() â€” Set Pipeline State and Draw

Replace the empty method:

```swift
private func encodeWedgeFill(encoder: MTLRenderCommandEncoder, bufferIndex: Int) {
    guard wedgeFillPipeline != nil else { return }

    encoder.setRenderPipelineState(wedgeFillPipeline)
    encoder.setCullMode(.back)
    encoder.setDepthStencilState(nil)  // Use default depth test

    // Bind buffers
    encoder.setVertexBuffer(vertexBuffers[bufferIndex],
                           offset: 0,
                           index: ScanGuidanceVertexDescriptor.BufferIndex.vertexData)
    encoder.setVertexBuffer(uniformBuffers[bufferIndex],
                           offset: 0,
                           index: ScanGuidanceVertexDescriptor.BufferIndex.uniforms)
    encoder.setVertexBuffer(perTriangleBuffers[bufferIndex],
                           offset: 0,
                           index: ScanGuidanceVertexDescriptor.BufferIndex.perTriangleData)

    // Fragment buffers
    encoder.setFragmentBuffer(uniformBuffers[bufferIndex],
                             offset: 0,
                             index: ScanGuidanceVertexDescriptor.BufferIndex.uniforms)

    // Draw indexed primitives
    // vertexCount and indexCount tracked from last uploadToBuffers call
    if currentVertexCount > 0 {
        encoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: currentVertexCount)
    }
}
```

**Note**: You'll need to add a `private var currentVertexCount: Int = 0` property to the class, and set it in `uploadToBuffers()`:
```swift
self.currentVertexCount = wedgeData.vertices.count
```

### 4.4 encodeBorderStroke() â€” Same Geometry, Different Shader

```swift
private func encodeBorderStroke(encoder: MTLRenderCommandEncoder, bufferIndex: Int) {
    guard borderStrokePipeline != nil else { return }

    encoder.setRenderPipelineState(borderStrokePipeline)
    encoder.setCullMode(.back)

    // Same buffer bindings as wedge fill
    encoder.setVertexBuffer(vertexBuffers[bufferIndex],
                           offset: 0,
                           index: ScanGuidanceVertexDescriptor.BufferIndex.vertexData)
    encoder.setVertexBuffer(uniformBuffers[bufferIndex],
                           offset: 0,
                           index: ScanGuidanceVertexDescriptor.BufferIndex.uniforms)
    encoder.setVertexBuffer(perTriangleBuffers[bufferIndex],
                           offset: 0,
                           index: ScanGuidanceVertexDescriptor.BufferIndex.perTriangleData)
    encoder.setFragmentBuffer(uniformBuffers[bufferIndex],
                             offset: 0,
                             index: ScanGuidanceVertexDescriptor.BufferIndex.uniforms)

    if currentVertexCount > 0 {
        encoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: currentVertexCount)
    }
}
```

### 4.5 Depth Stencil State

Add a `depthStencilState` property and create it in the initializer (after `createRenderPipelines()`):

```swift
private var depthStencilState: MTLDepthStencilState!

// In init(), after createRenderPipelines():
let depthDescriptor = MTLDepthStencilDescriptor()
depthDescriptor.depthCompareFunction = .less
depthDescriptor.isDepthWriteEnabled = true
self.depthStencilState = device.makeDepthStencilState(descriptor: depthDescriptor)
```

Then in `encodeWedgeFill()`:
```swift
encoder.setDepthStencilState(depthStencilState)
```

### 4.6 New Properties to Add

```swift
// Add to class properties:
private var currentVertexCount: Int = 0
private var depthStencilState: MTLDepthStencilState!
```

---

## CHAPTER 5: LOD0 WEDGE GEOMETRY â€” WedgeGeometryGenerator.swift

### 5.1 What LOD0 Must Produce

LOD0 is the highest-quality geometry: a triangular prism with **2-segment beveled edges** on all 6 edges (3 top, 3 bottom). This creates smooth rounded edges that catch specular highlights beautifully.

**Geometry breakdown per prism:**
- Top face: 1 triangle (3 vertices)
- Bottom face: 1 triangle (3 vertices)
- Top bevel: 3 edges Ã— 2 segments Ã— 2 triangles = 12 triangles (24 vertices)
- Bottom bevel: 3 edges Ã— 2 segments Ã— 2 triangles = 12 triangles (24 vertices)
- Side walls: 3 edges Ã— 2 triangles = 6 triangles (12 vertices)
- **Total: 44 triangles, ~66 unique vertices** (some sharing possible)

### 5.2 Implementation Strategy

The LOD0 implementation extends the LOD1 pattern (which uses 1-segment bevel). The key difference is:
- LOD1: bevel is a single flat strip connecting the face edge to the bevel offset â†’ 1 quad per edge
- LOD0: bevel is TWO curved strips, creating a smoother transition â†’ 2 quads per edge

Replace `generateFullLODWedge()` (lines 512-538) with this implementation:

```swift
private func generateFullLODWedge(
    v0: SIMD3<Float>, v1: SIMD3<Float>, v2: SIMD3<Float>,
    normal: SIMD3<Float>,
    thickness: Float,
    metallic: Float,
    roughness: Float,
    display: Float,
    triangleId: UInt32,
    vertices: inout [WedgeVertexCPU],
    indices: inout [UInt32],
    vertexIndex: inout UInt32
) {
    let bevelSegments = ScanGuidanceConstants.bevelSegmentsLOD0  // 2
    let bevelRadius = Float(ScanGuidanceConstants.bevelRadiusRatio) * thickness

    let baseIndex = vertexIndex

    // â”€â”€ Face positions â”€â”€
    let top0 = v0, top1 = v1, top2 = v2
    let bottom0 = v0 - normal * thickness
    let bottom1 = v1 - normal * thickness
    let bottom2 = v2 - normal * thickness

    // â”€â”€ Bevel inset positions â”€â”€
    let bevelOffset = normal * bevelRadius
    let topBevel0 = top0 - bevelOffset
    let topBevel1 = top1 - bevelOffset
    let topBevel2 = top2 - bevelOffset
    let bottomBevel0 = bottom0 + bevelOffset
    let bottomBevel1 = bottom1 + bevelOffset
    let bottomBevel2 = bottom2 + bevelOffset

    // Helper: generate bevel strip vertices for one edge with 2 segments
    // Returns 2Ã—(segments+1) vertices: outer ring and inner ring
    func bevelStrip(
        outerStart: SIMD3<Float>, outerEnd: SIMD3<Float>,
        innerStart: SIMD3<Float>, innerEnd: SIMD3<Float>,
        faceNormal: SIMD3<Float>,
        edgeDirection: SIMD3<Float>
    ) {
        let sideNormal = simdNormalize(simdCross(faceNormal, edgeDirection))
        let bNormals = bevelNormals(topFaceNormal: faceNormal, sideFaceNormal: sideNormal, segments: bevelSegments)

        // 2-segment bevel: 3 rows of 2 vertices each = 6 vertices
        // Row 0: outer edge (face edge)
        // Row 1: mid-bevel (halfway between face edge and bevel inset)
        // Row 2: bevel inset (connects to side wall)
        let midStart = (outerStart + innerStart) * 0.5
        let midEnd = (outerEnd + innerEnd) * 0.5

        // Normals for each row
        let n0 = bNormals[0]  // Face-aligned normal
        let n1 = bNormals.count > 1 ? bNormals[1] : simdNormalize(faceNormal + sideNormal)  // Mid-bevel
        let n2 = bNormals.count > 2 ? bNormals[2] : sideNormal  // Side-aligned normal

        // Row 0 (outer edge)
        vertices.append(WedgeVertexCPU(position: outerStart, normal: n0, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
        vertices.append(WedgeVertexCPU(position: outerEnd, normal: n0, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))

        // Row 1 (mid-bevel)
        vertices.append(WedgeVertexCPU(position: midStart, normal: n1, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
        vertices.append(WedgeVertexCPU(position: midEnd, normal: n1, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))

        // Row 2 (inner/bevel inset)
        vertices.append(WedgeVertexCPU(position: innerStart, normal: n2, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
        vertices.append(WedgeVertexCPU(position: innerEnd, normal: n2, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    }

    // â”€â”€ Top face center triangle (3 vertices, 1 triangle) â”€â”€
    vertices.append(WedgeVertexCPU(position: topBevel0, normal: normal, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: topBevel1, normal: normal, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: topBevel2, normal: normal, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))

    // Top face triangle
    indices.append(baseIndex)
    indices.append(baseIndex + 1)
    indices.append(baseIndex + 2)

    // â”€â”€ Top bevel strips (3 edges Ã— 6 vertices = 18 vertices, 3 edges Ã— 4 triangles = 12 triangles) â”€â”€
    var currentVertex = baseIndex + 3

    // Edge 0â†’1 top bevel
    bevelStrip(outerStart: top0, outerEnd: top1, innerStart: topBevel0, innerEnd: topBevel1,
               faceNormal: normal, edgeDirection: simdNormalize(top1 - top0))
    // 2 quads = 4 triangles from 6 vertices
    for seg in 0..<bevelSegments {
        let row = currentVertex + UInt32(seg * 2)
        indices.append(row); indices.append(row + 2); indices.append(row + 1)
        indices.append(row + 1); indices.append(row + 2); indices.append(row + 3)
    }
    currentVertex += 6

    // Edge 1â†’2 top bevel
    bevelStrip(outerStart: top1, outerEnd: top2, innerStart: topBevel1, innerEnd: topBevel2,
               faceNormal: normal, edgeDirection: simdNormalize(top2 - top1))
    for seg in 0..<bevelSegments {
        let row = currentVertex + UInt32(seg * 2)
        indices.append(row); indices.append(row + 2); indices.append(row + 1)
        indices.append(row + 1); indices.append(row + 2); indices.append(row + 3)
    }
    currentVertex += 6

    // Edge 2â†’0 top bevel
    bevelStrip(outerStart: top2, outerEnd: top0, innerStart: topBevel2, innerEnd: topBevel0,
               faceNormal: normal, edgeDirection: simdNormalize(top0 - top2))
    for seg in 0..<bevelSegments {
        let row = currentVertex + UInt32(seg * 2)
        indices.append(row); indices.append(row + 2); indices.append(row + 1)
        indices.append(row + 1); indices.append(row + 2); indices.append(row + 3)
    }
    currentVertex += 6

    // â”€â”€ Bottom face center triangle (3 vertices, 1 triangle) â”€â”€
    vertices.append(WedgeVertexCPU(position: bottomBevel0, normal: -normal, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel1, normal: -normal, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel2, normal: -normal, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))

    // Bottom face (reverse winding)
    indices.append(currentVertex + 2)
    indices.append(currentVertex + 1)
    indices.append(currentVertex)
    currentVertex += 3

    // â”€â”€ Bottom bevel strips (3 edges Ã— 6 vertices = 18 vertices, 12 triangles) â”€â”€
    // Edge 0â†’1 bottom bevel
    bevelStrip(outerStart: bottom0, outerEnd: bottom1, innerStart: bottomBevel0, innerEnd: bottomBevel1,
               faceNormal: -normal, edgeDirection: simdNormalize(bottom1 - bottom0))
    for seg in 0..<bevelSegments {
        let row = currentVertex + UInt32(seg * 2)
        indices.append(row); indices.append(row + 1); indices.append(row + 2)
        indices.append(row + 1); indices.append(row + 3); indices.append(row + 2)
    }
    currentVertex += 6

    // Edge 1â†’2 bottom bevel
    bevelStrip(outerStart: bottom1, outerEnd: bottom2, innerStart: bottomBevel1, innerEnd: bottomBevel2,
               faceNormal: -normal, edgeDirection: simdNormalize(bottom2 - bottom1))
    for seg in 0..<bevelSegments {
        let row = currentVertex + UInt32(seg * 2)
        indices.append(row); indices.append(row + 1); indices.append(row + 2)
        indices.append(row + 1); indices.append(row + 3); indices.append(row + 2)
    }
    currentVertex += 6

    // Edge 2â†’0 bottom bevel
    bevelStrip(outerStart: bottom2, outerEnd: bottom0, innerStart: bottomBevel2, innerEnd: bottomBevel0,
               faceNormal: -normal, edgeDirection: simdNormalize(bottom0 - bottom2))
    for seg in 0..<bevelSegments {
        let row = currentVertex + UInt32(seg * 2)
        indices.append(row); indices.append(row + 1); indices.append(row + 2)
        indices.append(row + 1); indices.append(row + 3); indices.append(row + 2)
    }
    currentVertex += 6

    // â”€â”€ Side walls (3 edges Ã— 4 vertices Ã— 2 triangles = 6 triangles) â”€â”€
    let sideNormal01 = simdNormalize(simdCross(normal, top1 - top0))
    vertices.append(WedgeVertexCPU(position: topBevel0, normal: sideNormal01, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel0, normal: sideNormal01, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: topBevel1, normal: sideNormal01, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel1, normal: sideNormal01, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    indices.append(currentVertex); indices.append(currentVertex + 1); indices.append(currentVertex + 2)
    indices.append(currentVertex + 2); indices.append(currentVertex + 1); indices.append(currentVertex + 3)
    currentVertex += 4

    let sideNormal12 = simdNormalize(simdCross(normal, top2 - top1))
    vertices.append(WedgeVertexCPU(position: topBevel1, normal: sideNormal12, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel1, normal: sideNormal12, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: topBevel2, normal: sideNormal12, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel2, normal: sideNormal12, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    indices.append(currentVertex); indices.append(currentVertex + 1); indices.append(currentVertex + 2)
    indices.append(currentVertex + 2); indices.append(currentVertex + 1); indices.append(currentVertex + 3)
    currentVertex += 4

    let sideNormal20 = simdNormalize(simdCross(normal, top0 - top2))
    vertices.append(WedgeVertexCPU(position: topBevel2, normal: sideNormal20, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel2, normal: sideNormal20, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: topBevel0, normal: sideNormal20, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    vertices.append(WedgeVertexCPU(position: bottomBevel0, normal: sideNormal20, metallic: metallic, roughness: roughness, display: display, thickness: thickness, triangleId: triangleId))
    indices.append(currentVertex); indices.append(currentVertex + 1); indices.append(currentVertex + 2)
    indices.append(currentVertex + 2); indices.append(currentVertex + 1); indices.append(currentVertex + 3)
    currentVertex += 4

    // â”€â”€ Final vertex count â”€â”€
    // 3 (top face) + 18 (top bevels) + 3 (bottom face) + 18 (bottom bevels) + 12 (sides) = 54
    vertexIndex = currentVertex
}
```

**Geometry verification**:
- Top face: 1 triangle
- Top bevels: 3 edges Ã— 2 segments Ã— 2 = 12 triangles
- Bottom face: 1 triangle
- Bottom bevels: 3 edges Ã— 2 segments Ã— 2 = 12 triangles
- Side walls: 3 edges Ã— 2 = 6 triangles
- **Total: 1 + 12 + 1 + 12 + 6 = 32 triangles** (Note: adjusted from 44 estimate â€” the 44 target from SSOT included corner triangles which are deferred to a future micro-optimization)

---

## CHAPTER 6: EVIDENCE RENDERER â€” EvidenceRenderer.swift

### 6.1 Current State

The current `EvidenceRenderer.swift` has an empty `MetalRenderView` placeholder. This needs to be connected to `ScanGuidanceRenderPipeline` for actual Metal-backed rendering.

### 6.2 Implementation Approach

Since the primary rendering path goes through `ARSCNView` delegate (where Metal commands are injected directly into the AR render loop), `EvidenceRenderer.swift` serves as an **alternative SwiftUI entry point** for non-AR contexts (e.g., preview mode, testing).

For the current phase, make it a passthrough that delegates to the pipeline:

```swift
#if canImport(SwiftUI)
import SwiftUI
import Foundation

#if canImport(MetalKit)
import MetalKit
#endif

/// SwiftUI view for rendering scan guidance evidence
/// Primary rendering path: ARSCNView delegate (ScanView â†’ ARCameraPreview)
/// This view: fallback for non-AR contexts or preview mode
public struct EvidenceRenderer: View {

    public init() {}

    public var body: some View {
        #if canImport(MetalKit)
        GeometryReader { geometry in
            // Metal rendering is handled by ScanGuidanceRenderPipeline
            // injected via ARSCNView delegate in the primary AR path.
            // This view provides a placeholder for non-AR preview contexts.
            ZStack {
                Color.black
                Text("Metal Renderer Active")
                    .font(.system(size: 12))
                    .foregroundColor(.gray.opacity(0.3))
            }
        }
        #else
        EmptyView()
        #endif
    }
}

#endif
```

This is intentionally minimal â€” the real Metal rendering happens in the ARSCNView delegate callback path, not through a SwiftUI view.

---

## CHAPTER 7: GPU MEMORY LAYOUT VERIFICATION

### 7.1 WedgeVertex â†” WedgeVertexCPU Alignment

The `ScanGuidanceVertexDescriptor` defines the GPU layout. Verify it matches:

| Attribute | Metal Type | CPU Type | Offset | Size |
|-----------|-----------|----------|--------|------|
| position | float3 | SIMD3<Float> | 0 | 12 |
| normal | float3 | SIMD3<Float> | 12 | 12 |
| metallic | float | Float | 24 | 4 |
| roughness | float | Float | 28 | 4 |
| display | float | Float | 32 | 4 |
| thickness | float | Float | 36 | 4 |
| triangleId | uint | UInt32 | 40 | 4 |
| **Total stride** | | | | **44 bytes** |

### 7.2 ScanGuidanceUniforms Layout

```
viewProjectionMatrix: float4x4    offset 0    size 64
modelMatrix: float4x4             offset 64   size 64
cameraPosition: float3            offset 128  size 12
_pad0: float                      offset 140  size 4   (alignment)
primaryLightDirection: float3     offset 144  size 12
primaryLightIntensity: float      offset 156  size 4
shCoeffs[9]: float3 Ã— 9          offset 160  size 144  (9 Ã— 16 = 144 with padding)
qualityTier: uint                 offset 304  size 4
time: float                       offset 308  size 4
borderGamma: float                offset 312  size 4
_pad1: float                      offset 316  size 4   (alignment)
Total:                                         320 bytes
```

**CRITICAL**: Metal struct alignment rules require float3 to be aligned to 16 bytes (same as float4). Verify that the Swift struct matches by using `MemoryLayout<GPUUniforms>.size` at runtime.

### 7.3 PerTriangleData Layout

```
flipAngle: float           offset 0   size 4
rippleAmplitude: float     offset 4   size 4
borderWidth: float         offset 8   size 4
flipAxisOrigin: float3     offset 12  size 12  (NOTE: may need 16-byte alignment!)
flipAxisDirection: float3  offset 28  size 12  (NOTE: alignment issue!)
grayscaleColor: float3     offset 40  size 12
Total:                              52 or 48 bytes (depends on alignment)
```

**ALIGNMENT WARNING**: Metal's `float3` in a struct may be 16-byte aligned (same as float4). If so, the layout becomes:

```
flipAngle: float           offset 0   size 4
rippleAmplitude: float     offset 4   size 4
borderWidth: float         offset 8   size 4
_pad: float                offset 12  size 4   (alignment to 16)
flipAxisOrigin: float3     offset 16  size 16  (padded to float4)
flipAxisDirection: float3  offset 32  size 16  (padded to float4)
grayscaleColor: float3     offset 48  size 16  (padded to float4)
Total:                              64 bytes
```

**RECOMMENDATION**: Change `PerTriangleData` in the .metal file to use explicit padding, or switch `float3` members to `packed_float3` to avoid alignment issues:

```metal
struct PerTriangleData {
    float  flipAngle;
    float  rippleAmplitude;
    float  borderWidth;
    packed_float3 flipAxisOrigin;
    packed_float3 flipAxisDirection;
    packed_float3 grayscaleColor;
};
```

With `packed_float3` (12 bytes, no padding): stride = 4+4+4+12+12+12 = **48 bytes**

Or keep `float3` (16-byte aligned) and adjust the CPU upload stride to **64 bytes**.

**Choose ONE approach and be consistent between .metal and Swift upload code.**

---

## CHAPTER 8: PERFORMANCE BUDGET

### 8.1 Target

- **60 FPS** = 16.67ms per frame total
- **CPU frame processing** (ScanViewModel.processARFrame): â‰¤ 4ms
- **GPU rendering** (Metal): â‰¤ 6ms
- **ARKit overhead**: ~4ms
- **SwiftUI/UIKit**: ~2ms

### 8.2 GPU Breakdown

| Pass | Expected Cost | Triangles |
|------|-------------|-----------|
| Wedge Fill (PBR) | 3-4ms | Up to 5000 Ã— LOD multiplier |
| Border Stroke | 0.5-1ms | Same geometry |
| **Total GPU** | **3.5-5ms** | |

### 8.3 Quality Philosophy: ALWAYS MAXIMUM

**âš ï¸ CRITICAL DESIGN DECISION: NO thermal degradation. ALWAYS run at maximum quality.**

The user's philosophy: "ç”¨æˆ·å°±æ˜¯è¦æœ€å¥½çš„æœåŠ¡" â€” Users deserve the best service, period.

| Setting | Value | Rationale |
|---------|-------|-----------|
| Max Triangles | 5000 | Always full capacity |
| LOD | LOD0 (full 2-segment bevel) | Always maximum geometry detail |
| Flip Animation | âœ“ Always enabled | Users deserve the full visual experience |
| Ripple Propagation | âœ“ Always enabled | Never disable visual feedback |
| PBR | Full Cook-Torrance + clearcoat + anisotropic | Always the best materials |
| RT-AO | âœ“ Always enabled (where hardware supports) | Always maximum lighting quality |
| MetalFX | âœ“ Always enabled at 67% render scale | Always use upscaling for maximum quality headroom |
| Particles | âœ“ Always enabled | Never disable visual polish |
| Motion Blur | âœ“ Always enabled | Always the cinematic experience |

**Do NOT implement thermal quality degradation tiers.** The `qualityTier` uniform should always be 0 (Nominal). The `ThermalQualityAdapter` still runs to collect GPU timing metrics (valuable telemetry), but its tier output is **ignored** for rendering decisions â€” always render at maximum quality.

**Future plan**: In a later version, a user-facing Settings page will allow users to choose quality presets (Ultra / High / Medium / Low) and toggle individual features (animations, particles, PBR complexity). But that is NOT this version. This version = maximum everything, always.

### 8.4 Optimization Techniques

1. **FP16 (`half`)**: All PBR calculations use `half` precision â€” 2Ã— throughput on Apple GPUs with negligible quality loss
2. **Early discard**: Border fragments with width < 0.5px are discarded
3. **Always maximum quality**: No tier-based branching â€” full PBR every frame (future: user-selectable quality presets)
4. **Triple buffering**: CPU and GPU work on different frames simultaneously via semaphore
5. **Buffer reuse**: Grow buffers geometrically (2Ã—) to avoid reallocation thrashing
6. **Indexed drawing**: Use index buffers to share vertices across triangles

---

## CHAPTER 9: IMPLEMENTATION ORDER

### Phase A: Metal Shader (.metal file) â€” DO THIS FIRST
1. Add PBR helper functions (NDF_GGX, GeometrySmith, FresnelSchlick, evaluateSH, quatFromAxisAngle, rotateByQuat)
2. Replace wedgeFillVertex with flip rotation + ripple displacement
3. Replace wedgeFillFragment with Cook-Torrance PBR
4. Replace borderStrokeFragment with SDF AA implementation
5. **Verify**: The .metal file should compile without errors in Xcode

### Phase B: Pipeline Swift code (ScanGuidanceRenderPipeline.swift)
1. Replace createRenderPipelines() â€” remove fatalError(), load shaders, create pipeline states
2. Add depthStencilState and currentVertexCount properties
3. Implement uploadToBuffers() with correct memory layout
4. Implement encodeWedgeFill() and encodeBorderStroke()
5. Update update() method to compute flipAxisData and grayscaleColors
6. **Verify**: `ScanGuidanceRenderPipeline(device:)` initializes without crash

### Phase C: LOD0 Geometry (WedgeGeometryGenerator.swift)
1. Replace generateFullLODWedge() with 2-segment bevel implementation
2. Verify vertex count and index count match expected values
3. **Verify**: `swift build` passes, `swift test --filter ScanGuidanceTests` passes (74 tests)

### Phase D: Evidence Renderer (EvidenceRenderer.swift)
1. Update to minimal Metal-aware placeholder
2. **Verify**: Builds without error

### Phase E: Integration Verification
1. `swift build` â€” Core/ not affected
2. `swift test --filter ScanGuidanceTests` â€” all 74 tests still pass
3. Open in Xcode, build for iOS device
4. Run on device: verify Metal rendering activates (polished black triangles visible)
5. Test flip animation: coverage changes trigger smooth 180Â° rotations with specular glints
6. Verify maximum quality: confirm LOD0 + full PBR + all animations always active regardless of thermal state
7. Push to branch, verify 4 CI workflows green

---

## CHAPTER 10: ANTI-PATTERNS â€” DO NOT DO THESE

1. **DO NOT** add new files â€” you're modifying exactly 4 existing files
2. **DO NOT** modify ScanViewModel.swift â€” the UI layer is sealed
3. **DO NOT** modify ScanGuidanceConstants.swift â€” all constants are immutable SSOT
4. **DO NOT** use `float` for intermediate PBR calculations â€” use `half` for 2Ã— throughput
5. **DO NOT** create a third render pass â€” PBR lighting is integrated into wedgeFillFragment
6. **DO NOT** use matrix multiplication for rotation â€” quaternions are 80% faster
7. **DO NOT** allocate Metal buffers per frame â€” use triple-buffered reusable buffers
8. **DO NOT** ignore Metal struct alignment â€” `float3` may be 16-byte aligned in structs
9. **DO NOT** forget pre-multiplied alpha â€” AR overlay compositing requires `color.rgb *= alpha`
10. **DO NOT** implement thermal quality degradation â€” always render at maximum quality (LOD0, full PBR, all animations). ThermalQualityAdapter collects metrics only; its tier output is ignored for rendering decisions
11. **DO NOT** hardcode light direction â€” use ARKit's `primaryLightDirection` from uniforms
12. **DO NOT** normalize ARKit SH coefficients to [0,1] â€” they're in lux units, normalize by L0 band

---

## CHAPTER 11: VERIFICATION CHECKLIST

### Compilation
- [ ] `swift build` succeeds (Core/ not affected)
- [ ] `swift test --filter ScanGuidanceTests` â€” all 74 tests pass
- [ ] Xcode build for iOS succeeds without warnings in modified files
- [ ] ScanGuidanceRenderPipeline initializes without fatalError

### Visual
- [ ] Triangles render as polished black metal with visible specular highlights
- [ ] Flip animation produces smooth 180Â° rotation with overshoot
- [ ] Specular glint visible during flip rotation (natural from low-roughness GGX)
- [ ] Ripple displacement creates visible wave propagation from flip sources
- [ ] Borders render as anti-aliased white lines with adaptive width
- [ ] Alpha fadeout at S5 threshold (display â‰¥ 0.88)
- [ ] Pre-multiplied alpha compositing looks correct over AR camera

### Performance
- [ ] 60 FPS maintained on iPhone 13+ (nominal tier)
- [ ] Always renders at maximum quality (LOD0 + full PBR + all animations) regardless of thermal state
- [ ] GPU frame time â‰¤ 6ms (use Metal System Trace to verify)
- [ ] No buffer reallocation per frame (verify with Metal Allocation instrument)

### Safety
- [ ] No modifications to Core/ files (except WedgeGeometryGenerator LOD0 only)
- [ ] No modifications to ScanGuidanceConstants
- [ ] No modifications to UI layer files (App/Scan/, App/Home/)
- [ ] All constants read from ScanGuidanceConstants
- [ ] 4 CI workflows pass after push

---

## APPENDIX A: EXISTING API SIGNATURES (Verified from Source)

### FlipAnimationController (Core/)
```swift
func checkThresholdCrossings(previousDisplay: [String: Double], currentDisplay: [String: Double], triangles: [ScanTriangle], adjacencyGraph: any AdjacencyProvider) -> [Int]
func tick(deltaTime: TimeInterval) -> [Float]
func getFlipAngles(for triangleIndices: [Int]) -> [Float]
func getFlipAxis(for triangleIndex: Int) -> (origin: SIMD3<Float>, direction: SIMD3<Float>)?
func reset()
```

### RipplePropagationEngine (Core/)
```swift
func spawn(sourceTriangle: Int, adjacencyGraph: any AdjacencyProvider, timestamp: TimeInterval)
func tick(currentTime: TimeInterval) -> [Float]
func getRippleAmplitudes(for triangleIndices: [Int], currentTime: TimeInterval) -> [Float]
func reset()
```

### WedgeGeometryGenerator (Core/)
```swift
func generate(triangles: [ScanTriangle], displayValues: [String: Double], lod: LODLevel) -> WedgeVertexData
func thickness(display: Double, areaSqM: Float, medianArea: Float) -> Float
func bevelNormals(topFaceNormal: SIMD3<Float>, sideFaceNormal: SIMD3<Float>, segments: Int) -> [SIMD3<Float>]
```

### GrayscaleMapper (App/)
```swift
func grayscale(for display: Double) -> (r: Float, g: Float, b: Float)
```

### EnvironmentLightEstimator (App/)
```swift
func update(lightEstimate: Any?, cameraImage: Any?, timestamp: TimeInterval) -> LightState
```

### ScanGuidanceVertexDescriptor (App/)
```swift
static func create() -> MTLVertexDescriptor
enum BufferIndex { static let vertexData = 0; static let uniforms = 1; static let perTriangleData = 2 }
```

---

## APPENDIX B: ACADEMIC REFERENCES

1. **Cook-Torrance BRDF**: Cook & Torrance, "A Reflectance Model for Computer Graphics", SIGGRAPH 1982
2. **GGX/Trowbridge-Reitz NDF**: Walter et al., "Microfacet Models for Refraction through Rough Surfaces", EGSR 2007
3. **Schlick Fresnel**: Schlick, "An Inexpensive BRDF Model for Physically-based Rendering", Eurographics 1994
4. **Smith Geometry Function**: Heitz, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs", JCGT 2014
5. **L2 Spherical Harmonics**: Ramamoorthi & Hanrahan, "An Efficient Representation for Irradiance Environment Maps", SIGGRAPH 2001
6. **Quaternion Rotation**: Shoemake, "Animating Rotation with Quaternion Curves", SIGGRAPH 1985
7. **Stevens' Power Law**: Stevens, "On the psychophysical law", Psychological Review, 1957

---

---

# PART II: EXTREME PERFORMANCE â€” BEYOND APPLE, BEYOND GOOD ENOUGH

The following chapters describe rendering upgrades that go **far beyond** what Apple's own apps (RealityKit, Object Capture, SceneKit) implement. These are not optional nice-to-haves â€” they are the **performance headroom and visual superiority** that make Aether3D the best 3D scanner on the planet. Every technique listed here either (a) Apple doesn't have it in their real-time apps, or (b) we do it better.

The philosophy: **today's headroom is tomorrow's baseline**. Build with 5Ã— the capacity you need right now.

---

## CHAPTER 12: ADVANCED PBR â€” BEYOND COOK-TORRANCE

Standard Cook-Torrance GGX is what everyone uses. We go further.

### 12.1 Geometric Specular Anti-Aliasing (PRIORITY: CRITICAL)

**Problem**: Small wedge triangles at distance produce flickering specular highlights because GGX NDF is narrower than a pixel. This DESTROYS the polished metal illusion during camera motion.

**No iOS app does this on custom mesh shaders.**

Add to `wedgeFillFragment` BEFORE evaluating the BRDF:

```metal
// Specular anti-aliasing: widen roughness to cover pixel footprint
// Prevents shimmer on small/distant triangles
inline half specularAARoughness(float3 worldNormal, half roughness) {
    float3 dNdx = dfdx(worldNormal);
    float3 dNdy = dfdy(worldNormal);
    half variance = half(dot(dNdx, dNdx) + dot(dNdy, dNdy));
    half kernelRoughness = min(variance, 0.18h);
    return sqrt(roughness * roughness + kernelRoughness);
}
```

Cost: **~0.0ms** (5 ALU instructions). Non-negotiable for small geometry.

### 12.2 Multi-Scattering GGX Energy Compensation (Kulla-Conty)

**Problem**: Standard single-scatter GGX loses 30-50% energy at high roughness, making rough metals unnaturally dark.

**RealityKit does NOT implement this. Google Filament does.**

```metal
// Kulla-Conty energy compensation â€” recovers lost multi-scatter energy
inline half3 multiScatterCompensation(half3 F0, half NdotV, half roughness) {
    // Analytical approximation of directional albedo
    half a = roughness;
    half Ess = 1.0h - max(0.0h,
        (0.04h + 0.96h * pow(1.0h - NdotV, 5.0h)) *
        exp2(-9.28h * NdotV - 0.78h * a) +
        a * (0.23h + 0.45h * NdotV));
    half Ems = 1.0h - Ess;
    half3 Favg = F0 + (1.0h - F0) / 21.0h;
    half3 compensation = Favg * Ems / (1.0h - Favg * Ems);
    return 1.0h + F0 * compensation;
}

// In wedgeFillFragment, multiply specular BRDF result:
// half3 specularMultiScatter = specular * multiScatterCompensation(F0, NdotV, roughness);
```

Cost: **~0.0ms** (5 ALU). Massive quality improvement on matte regions.

### 12.3 Anisotropic GGX for Beveled Edges

**Problem**: Isotropic GGX produces circular specular blobs. Machined/brushed metal has elongated highlights along the machining direction. Beveled edges should reflect light in streaks, not dots.

**RealityKit added basic anisotropy in iOS 18, but NO app uses bevel-aligned tangent frames.**

```metal
// Anisotropic GGX NDF (Filament model)
inline half D_GGX_Anisotropic(half NdotH, half TdotH, half BdotH,
                               half alpha_t, half alpha_b) {
    half a2 = alpha_t * alpha_b;
    half3 d = half3(alpha_b * TdotH, alpha_t * BdotH, a2 * NdotH);
    half d2 = dot(d, d);
    half b2 = a2 / d2;
    return a2 * b2 * b2 * (1.0h / M_PI_H);
}

// Parameterize from single anisotropy value [-1, 1]:
// half at = max(roughness * (1.0h + anisotropy), 0.001h);
// half ab = max(roughness * (1.0h - anisotropy), 0.001h);
```

Requires tangent vectors computed per-vertex from the bevel edge direction. Add `float3 tangent` to WedgeVertexCPU and WedgeVertex struct (attribute 7). The tangent is the edge direction for bevel faces, the longest-edge direction for top/bottom faces.

### 12.4 Clearcoat Layer (Two-Layer BRDF)

**Problem**: Single-layer metal lacks the "wet/polished/lacquered" look. Real polished metal has a transparent glossy layer producing a second sharp highlight â€” like automotive paint.

```metal
// Clearcoat specular (cheap Kelemen visibility approximation)
inline half3 evaluateClearcoat(half NdotH, half LdotH, half clearcoatStrength, half clearcoatRoughness) {
    half alpha = clearcoatRoughness * clearcoatRoughness;
    half D = NDF_GGX(NdotH, half(clearcoatRoughness));
    half V = 0.25h / (LdotH * LdotH);  // Kelemen visibility
    half F = 0.04h + 0.96h * pow(1.0h - LdotH, 5.0h);
    return half3(D * V * F * clearcoatStrength);
}

// In fragment shader:
// half3 clearcoat = evaluateClearcoat(NdotH, LdotH, 0.8, 0.05);
// half clearcoatAttenuation = 1.0h - fresnelClearcoat * clearcoatStrength;
// color = (diffuse + specular) * clearcoatAttenuation + clearcoat;
```

Cost: **~0.1ms** (20 ALU, one extra GGX eval). Dramatic visual impact.

### 12.5 Subsurface Scattering Edge Glow

**Problem**: Thin bevel edges look opaque and flat. Real thin geometry transmits some light, creating a subtle warm glow at edges.

**Unique to wedge geometry â€” no competitor has per-vertex thickness-driven SSS.**

```metal
// Thin-film transmission approximation using WedgeVertex.thickness
inline half3 edgeTransmission(float3 N, float3 L, float3 V, half thickness, half3 baseColor) {
    half wrap = 0.2h;
    half NdotL_wrap = (half(dot(N, L)) + wrap) / (1.0h + wrap);
    half transmittance = saturate(exp(-thickness * 100.0h));  // thickness in meters â†’ scale
    half backScatter = saturate(half(dot(-N, L))) * 0.5h + saturate(half(dot(V, -L))) * 0.5h;
    return baseColor * transmittance * backScatter * 0.3h;
}
```

Cost: **~0.0ms** (5 ALU). Adds depth perception to bevel edges.

### 12.6 Area Light Approximation (Representative Point)

**Problem**: ARKit's `primaryLightDirection` is a point/directional light producing unnaturally sharp specular dots. Real lights have area, producing softer, larger highlights.

**No iOS AR app implements this.**

```metal
// Representative point method: soften specular by treating the light as a sphere
inline float3 areaLightRepresentativePoint(float3 worldPos, float3 lightPos, float3 R, float lightRadius) {
    float3 L = lightPos - worldPos;
    float3 centerToRay = dot(L, R) * R - L;
    float3 closestPoint = lightPos + centerToRay * saturate(lightRadius / length(centerToRay));
    return normalize(closestPoint - worldPos);
}

// Modify roughness to account for light size:
// half alpha_new = saturate(alpha + half(lightRadius / (2.0 * length(lightPos - worldPos))));
```

### 12.7 Per-Vertex Ambient Occlusion

**Problem**: Without AO, flat-shaded wedge geometry looks like paper cutouts. AO darkens concave areas (gaps between wedges, inside bevel edges) and adds depth.

Compute during mesh generation on CPU (FREE at runtime):

```swift
// In WedgeGeometryGenerator: compute AO for each vertex
// Side wall vertices get AO = 0.6 (recessed)
// Top face vertices get AO = 1.0 (exposed)
// Bevel vertices get AO = 0.7-0.9 (partially occluded)
```

Add `float ao` to WedgeVertexCPU (attribute 8). Multiply ambient/indirect lighting by AO in fragment shader:
```metal
half3 indirect = (indirectDiffuse + indirectSpecular) * half(in.ao);
```

### 12.8 Iridescence / Thin-Film Interference (Optional Luxury)

For display â‰¥ 0.88 (near S5), add rainbow thin-film interference as a visual reward:

```metal
inline half3 thinFilmIridescence(half cosTheta, half filmThickness, half filmIOR) {
    half cosThetaFilm = sqrt(1.0h - (1.0h / (filmIOR * filmIOR)) * (1.0h - cosTheta * cosTheta));
    half OPD = 2.0h * filmIOR * filmThickness * cosThetaFilm;
    half3 wavelengths = half3(650.0h, 550.0h, 450.0h);
    half3 phase = 2.0h * M_PI_H * OPD / wavelengths;
    return 0.5h + 0.5h * cos(phase);
}
```

---

## CHAPTER 13: GPU COMPUTE ANIMATION PIPELINE â€” ZERO CPU OVERHEAD

### 13.1 Architecture: Three Compute Passes + One Render Pass

Move the ENTIRE animation pipeline off the CPU:

```
Compute Pass 1: Threshold Detection + Flip State Update
    - Read: coverageBuffer, previousCoverageBuffer, flipStateBuffer
    - Write: flipStateBuffer (angles, velocities, axis data)
    - 1 thread per triangle

Compute Pass 2: Spring-Mass Ripple Physics
    - Read: flipStateBuffer, adjacencyBuffer, springStateBuffer[frameN-1]
    - Write: springStateBuffer[frameN]
    - 4 substeps per frame for stability
    - 1 thread per triangle per substep

Compute Pass 3: Vertex Skinning (Dual Quaternion)
    - Read: inputVertexBuffer, flipStateBuffer, springStateBuffer
    - Write: transformedVertexBuffer
    - Dual quaternion rotation (volume-preserving)
    - 1 thread per vertex

Render Pass: Draw transformed vertices (vertex shader = passthrough)
```

**This eliminates 2-5ms of CPU computation + buffer upload per frame.** All three compute passes complete in **0.3-0.5ms** for 100K triangles on A15+.

### 13.2 Spring-Mass Physics (Replaces Scripted BFS Ripple)

Instead of scripted BFS ripple with preset delays, model triangles as masses connected by springs. Flip events inject angular impulses that propagate ORGANICALLY through the spring network:

```metal
// Spring-Mass compute kernel
kernel void springMassUpdate(
    device SpringMassState *state [[buffer(0)]],
    device const SpringMassState *prevState [[buffer(1)]],
    device const AdjacencyEntry *adjacency [[buffer(2)]],
    constant SimParams &params [[buffer(3)]],
    uint tid [[thread_position_in_grid]]
) {
    SpringMassState s = prevState[tid];
    float force = 0.0;

    // Accumulate spring forces from neighbors
    uint neighborStart = adjacency[tid].offset;
    uint neighborCount = adjacency[tid].count;
    for (uint i = 0; i < neighborCount; i++) {
        uint neighbor = adjacency[neighborStart + i].triangleIndex;
        float displacement = prevState[neighbor].angularDisplacement - s.angularDisplacement;
        float relativeVelocity = prevState[neighbor].velocity - s.velocity;
        force += params.springK * displacement + params.dampingC * relativeVelocity;
    }

    // External force (flip impulse)
    force += s.externalForce;

    // Symplectic Euler integration
    s.velocity += (force / s.mass) * params.subDt;
    s.angularDisplacement += s.velocity * params.subDt;
    s.externalForce = 0.0;  // Consumed

    state[tid] = s;
}
```

Visual result: **wave interference when two flips overlap, reflection off mesh boundaries, natural resonance effects** â€” completely impossible with scripted BFS.

### 13.3 Dual Quaternion Skinning (Volume-Preserving Rotation)

Replace simple quaternion rotation with dual quaternions to prevent the "candy wrapper" artifact:

```metal
struct DualQuat {
    float4 real;  // Rotation
    float4 dual;  // Translation
};

inline DualQuat dualQuatFromAxisAnglePivot(float3 axis, float angle, float3 pivot) {
    float4 qr = quatFromAxisAngle(axis, angle);
    float3 t = pivot - rotateByQuat(pivot, qr);
    float4 qd = float4(
        0.5 * ( t.x * qr.w + t.y * qr.z - t.z * qr.y),
        0.5 * (-t.x * qr.z + t.y * qr.w + t.z * qr.x),
        0.5 * ( t.x * qr.y - t.y * qr.x + t.z * qr.w),
        0.5 * (-t.x * qr.x - t.y * qr.y - t.z * qr.z)
    );
    return {qr, qd};
}

inline float3 transformByDualQuat(float3 v, DualQuat dq) {
    float3 rotated = rotateByQuat(v, dq.real);
    float3 trans = 2.0 * (dq.real.w * dq.dual.xyz - dq.dual.w * dq.real.xyz
                         + cross(dq.real.xyz, dq.dual.xyz));
    return rotated + trans;
}
```

Cost: **~0.003ms** for 300K vertices. Prevents geometry shrinkage at rotation axis.

### 13.4 Procedural Simplex Noise for Surface Imperfections

Generate micro-surface detail (brushed streaks, micro-scratches, fingerprint smudges) entirely in the fragment shader. **No textures needed. Infinite resolution at any zoom.**

```metal
// 4 noise layers modulate roughness and metallic:
// Layer 1: Brushed metal streaks â€” roughness += noise(worldPos * (2,50,2)) * 0.03
// Layer 2: Micro-scratches â€” roughness += threshold(noise(worldPos * 200)) * 0.15
// Layer 3: Fingerprint smudges â€” roughness += sparse_mask * 0.08, metallic -= 0.05
// Layer 4: Surface waviness â€” normal perturbation via finite differences
```

Even 0.03 roughness variation creates the subconscious impression of a PHYSICAL surface rather than CGI.

### 13.5 GPU Particle System â€” Metallic Sparks on Flip

When a triangle flips, emit metallic spark particles along the rotation edge:

- Particle pool with atomic allocation (`atomic_fetch_add`)
- Physics: gravity + air drag + position integration
- Rendering: point sprites with metallic PBR, warm gold â†’ red cooling
- Cost: **0.07ms for 10K particles**

### 13.6 Per-Object Motion Blur

Velocity buffer pass + full-screen post-process for flipping triangles:

- Store `(currentNDC - previousNDC)` per pixel as screen-space velocity
- Post-process: 8 samples along velocity vector
- Only flipping triangles blur; static geometry stays sharp
- Cost: **0.2ms at 1080p**. Transforms flip from "digital transition" to "physical rotation with momentum."

---

## CHAPTER 14: APPLE GPU ARCHITECTURE EXPLOITATION â€” TBDR DEEP OPTIMIZATION

### 14.1 Memoryless Render Targets (PRIORITY: IMMEDIATE)

**All Apple GPUs support this. RealityKit uses it. We must too.**

Depth/stencil attachments that NEVER leave tile memory â€” zero DRAM allocation:

```swift
let depthDesc = MTLTextureDescriptor.texture2DDescriptor(
    pixelFormat: .depth32Float, width: w, height: h, mipmapped: false)
depthDesc.storageMode = .memoryless  // Never allocates DRAM
depthDesc.usage = .renderTarget
let depthTexture = device.makeTexture(descriptor: depthDesc)!

renderPassDescriptor.depthAttachment.texture = depthTexture
renderPassDescriptor.depthAttachment.storeAction = .dontCare  // Discard after tile
```

Saves **1.9-2.4 GB/s bandwidth** at 60fps. Cost: **20 LOC**.

### 14.2 Resource Heaps (Sub-Allocation)

Instead of individual `device.makeBuffer()` calls, sub-allocate from a single heap:

```swift
let heapDesc = MTLHeapDescriptor()
heapDesc.size = 16 * 1024 * 1024  // 16MB heap
heapDesc.storageMode = .shared
heapDesc.hazardTrackingMode = .untracked  // A11+ â€” manual sync, faster
let heap = device.makeHeap(descriptor: heapDesc)!

// Sub-allocate from heap (10-25Ã— faster than makeBuffer)
let vertexBuffer = heap.makeBuffer(length: vertexSize, options: [])!
let uniformBuffer = heap.makeBuffer(length: uniformSize, options: [])!
```

### 14.3 MTLSharedEvent (Replace DispatchSemaphore)

Replace DispatchSemaphore with GPU timeline synchronization â€” eliminates kernel transitions:

```swift
let sharedEvent = device.makeSharedEvent()!
var frameCounter: UInt64 = 0

// In encode():
frameCounter += 1
commandBuffer.encodeSignalEvent(sharedEvent, value: frameCounter)

// CPU waits only when needed (non-blocking check):
let listener = MTLSharedEventListener(dispatchQueue: .main)
sharedEvent.notify(listener, atValue: frameCounter - 2) { event, value in
    // Frame N-2 is done, safe to reuse buffer
}
```

Saves **0.5-2ms CPU stalls per frame**.

### 14.4 Rasterization Rate Maps (Variable Rate Shading)

**visionOS uses this. iOS AR apps do NOT. Major competitive advantage.**

Render center of AR view at full rate, periphery at half:

```swift
let layerDesc = MTLRasterizationRateLayerDescriptor(
    horizontal: [0.5, 1.0, 0.5],  // Left 1/3 at half, center at full, right 1/3 at half
    vertical: [0.5, 1.0, 0.5]     // Same vertically
)
let rateMapDesc = MTLRasterizationRateMapDescriptor(screenSize: viewportSize, layer: layerDesc)
let rateMap = device.makeRasterizationRateMap(descriptor: rateMapDesc)!
renderPassDescriptor.rasterizationRateMap = rateMap
```

Saves **30-50% fragment shader cost** â€” ~1-2ms on complex PBR.

### 14.5 Indirect Command Buffers (GPU-Driven Rendering)

Let the GPU decide what to draw â€” zero CPU draw call overhead:

```swift
let icbDesc = MTLIndirectCommandBufferDescriptor()
icbDesc.commandTypes = .draw
icbDesc.inheritPipelineState = true
icbDesc.inheritBuffers = true
icbDesc.maxVertexBufferBindCount = 3
icbDesc.maxFragmentBufferBindCount = 3
let icb = device.makeIndirectCommandBuffer(descriptor: icbDesc, maxCommandCount: 10000)!

// GPU compute kernel fills ICB commands based on frustum culling results
// CPU just executes:
renderEncoder.executeCommandsInBuffer(icb, range: 0..<visibleCount)
```

Eliminates **3-5ms CPU overhead** for complex scenes.

### 14.6 GPU Performance Counters (Real-Time Telemetry)

Monitor GPU utilization in real-time for adaptive quality:

```swift
if let counterSets = device.counterSets {
    for cs in counterSets {
        if cs.name == "timestamp" {
            let desc = MTLCounterSampleBufferDescriptor()
            desc.counterSet = cs
            desc.sampleCount = 4
            desc.storageMode = .shared
            let sampleBuffer = try device.makeCounterSampleBuffer(descriptor: desc)
            // Attach to render pass for per-pass timing
            renderPassDescriptor.sampleBufferAttachments[0].sampleBuffer = sampleBuffer
            renderPassDescriptor.sampleBufferAttachments[0].startOfVertexSampleIndex = 0
            renderPassDescriptor.sampleBufferAttachments[0].endOfVertexSampleIndex = 1
            renderPassDescriptor.sampleBufferAttachments[0].startOfFragmentSampleIndex = 2
            renderPassDescriptor.sampleBufferAttachments[0].endOfFragmentSampleIndex = 3
        }
    }
}
```

Feed GPU timing directly to ThermalQualityAdapter for **telemetry collection only** â€” metrics are logged for future analysis but rendering always stays at maximum quality. The adapter's tier output is ignored for rendering decisions in this version.

---

## CHAPTER 15: MetalFX TEMPORAL UPSCALING â€” 2Ã— PERFORMANCE FREE

**RealityKit does NOT use MetalFX. This is our single biggest performance advantage.**

Render at 67% resolution, MetalFX upscales to native with quality matching 4Ã— MSAA:

```swift
import MetalFX

let descriptor = MTLFXTemporalScalerDescriptor()
descriptor.inputWidth = Int(Float(viewportWidth) * 0.67)
descriptor.inputHeight = Int(Float(viewportHeight) * 0.67)
descriptor.outputWidth = viewportWidth
descriptor.outputHeight = viewportHeight
descriptor.colorTextureFormat = .bgra8Unorm
descriptor.depthTextureFormat = .depth32Float
descriptor.motionTextureFormat = .rg16Float
descriptor.outputTextureFormat = .bgra8Unorm
descriptor.isAutoExposureEnabled = true

guard let temporalScaler = descriptor.makeTemporalScaler(device: device) else { return }

// Per frame:
temporalScaler.colorTexture = colorTexture
temporalScaler.depthTexture = depthTexture
temporalScaler.motionTexture = motionVectorTexture  // From vertex shader
temporalScaler.outputTexture = outputTexture
temporalScaler.jitterOffsetX = haltonSequence[frameIndex % 16].x  // Sub-pixel jitter
temporalScaler.jitterOffsetY = haltonSequence[frameIndex % 16].y
temporalScaler.reset = false  // Set true on camera cuts
temporalScaler.encode(commandBuffer: commandBuffer)
```

**Motion vectors** for flip animation:

```metal
// In vertex shader: compute motion vector from current and previous frame transforms
float4 currentClip = uniforms.viewProjectionMatrix * worldPos;
float4 prevClip = uniforms.previousViewProjectionMatrix * prevWorldPos;
float2 currentNDC = currentClip.xy / currentClip.w;
float2 prevNDC = prevClip.xy / prevClip.w;
out.motionVector = (currentNDC - prevNDC) * 0.5;  // Write to motion texture
```

Hardware: **A15+, iOS 16+**. Effective **2-4Ã— fragment shader speedup**.

---

## CHAPTER 16: METAL 3 MESH SHADERS â€” GPU-ONLY GEOMETRY

**NOT used by RealityKit or Object Capture. Strongest competitive advantage.**

Mesh shaders eliminate the entire CPU vertex buffer for LOD selection. The GPU generates geometry:

```swift
let meshDesc = MTLMeshRenderPipelineDescriptor()
meshDesc.objectFunction = library.makeFunction(name: "objectShader")
meshDesc.meshFunction = library.makeFunction(name: "meshShader")
meshDesc.fragmentFunction = library.makeFunction(name: "wedgeFillFragment")
meshDesc.payloadMemoryLength = 16384  // 16KB max payload
meshDesc.maxTotalThreadsPerObjectThreadgroup = 256
meshDesc.maxTotalThreadsPerMeshThreadgroup = 256
meshDesc.colorAttachments[0].pixelFormat = .bgra8Unorm
meshDesc.depthAttachmentPixelFormat = .depth32Float
let meshPipeline = try device.makeRenderPipelineState(descriptor: meshDesc, options: [])

// Draw:
renderEncoder.setRenderPipelineState(meshPipeline)
renderEncoder.drawMeshThreadgroups(
    MTLSize(width: meshletCount, height: 1, depth: 1),
    threadsPerObjectThreadgroup: MTLSize(width: 32, height: 1, depth: 1),
    threadsPerMeshThreadgroup: MTLSize(width: 128, height: 1, depth: 1)
)
```

Object shader does frustum culling + LOD selection. Mesh shader generates beveled wedge geometry on-the-fly. **50-90% invisible geometry culled BEFORE rasterizer.**

Hardware: **A14/M1+** (apple7 family).

---

## CHAPTER 17: RAY-TRACED AMBIENT OCCLUSION â€” REAL-TIME QUALITY

**Object Capture bakes AO offline. RealityKit uses screen-space only. We do REAL ray-traced AO in real-time.**

```swift
// Build acceleration structure from wedge geometry
let geoDesc = MTLAccelerationStructureTriangleGeometryDescriptor()
geoDesc.vertexBuffer = vertexBuffer
geoDesc.indexBuffer = indexBuffer
geoDesc.triangleCount = triangleCount

let accelDesc = MTLPrimitiveAccelerationStructureDescriptor()
accelDesc.geometryDescriptors = [geoDesc]

let sizes = device.accelerationStructureSizes(descriptor: accelDesc)
let accelStructure = device.makeAccelerationStructure(size: sizes.accelerationStructureSize)!
let scratchBuffer = device.makeBuffer(length: sizes.buildScratchBufferSize)!

let buildEncoder = commandBuffer.makeAccelerationStructureCommandEncoder()!
buildEncoder.build(accelerationStructure: accelStructure,
                   descriptor: accelDesc,
                   scratchBuffer: scratchBuffer,
                   scratchBufferOffset: 0)
buildEncoder.endEncoding()
```

AO compute kernel (1-2 rays per pixel at quarter resolution):

```metal
kernel void computeAO(
    texture2d<float, access::read> depthTex [[texture(0)]],
    texture2d<float, access::write> aoTex [[texture(1)]],
    instance_acceleration_structure accel [[buffer(0)]],
    constant AOParams &params [[buffer(1)]],
    uint2 tid [[thread_position_in_grid]]
) {
    float depth = depthTex.read(tid * 2).r;  // Quarter res
    float3 worldPos = reconstructWorldPos(tid * 2, depth, params);
    float3 normal = reconstructNormal(depthTex, tid * 2, params);

    float occlusion = 0.0;
    for (int i = 0; i < 2; i++) {  // 2 rays per pixel
        float3 dir = cosineWeightedHemisphere(normal, hash(tid, i, params.frameIndex));
        ray r;
        r.origin = worldPos + normal * 0.001;
        r.direction = dir;
        r.min_distance = 0.001;
        r.max_distance = 0.1;  // 10cm AO radius

        intersector<accept_any> inter;
        auto result = inter.intersect(r, accel);
        occlusion += (result.type != intersection_type::none) ? 1.0 : 0.0;
    }

    aoTex.write(1.0 - occlusion * 0.5, tid);
}
```

Cost: **2-4ms at quarter resolution on A15+**. Refit (not rebuild) acceleration structure each frame for animated geometry: **~0.5ms**.

Hardware: **A13+** (apple6 family).

---

## CHAPTER 18: ADAPTIVE TESSELLATION + LOD MORPHING

### 18.1 Hardware Tessellation with PN-Triangles

Metal's fixed-function tessellation dynamically subdivides close triangles for perfectly smooth bevels:

```swift
let tessDesc = MTLRenderPipelineDescriptor()
tessDesc.maxTessellationFactor = 16
tessDesc.tessellationPartitionMode = .fractionalEven  // Smooth transitions
tessDesc.tessellationOutputWindingOrder = .counterClockwise
```

PN-Triangles (curved point-normal) provide cubic Bezier interpolation. Six edge control points computed from patch corners + normals. At factor 8, 10K visible patches produce 640K sub-triangles â€” well within A15 rasterization budget.

### 18.2 LOD Morphing (Geomorphing)

Instead of hard LOD switches that cause visible "popping," smoothly interpolate between LOD levels:

```metal
// In vertex shader:
float morphFactor = smoothstep(nearDist, farDist, cameraDistance);
float3 position = mix(posLOD0, posLOD1, morphFactor);
float3 normal = normalize(mix(normalLOD0, normalLOD1, morphFactor));
```

Each vertex stores both LOD0 and LOD1 positions. The morph smoothly animates vertex collapse. Cost: **~0.001ms** for 300K vertices.

---

## CHAPTER 19: IBL SPLIT-SUM â€” ACCURATE SPECULAR REFLECTIONS

### 19.1 Pre-Filtered Environment Map from ARKit Probe

Replace SH-only specular with proper IBL Split-Sum:

```swift
// When ARKit provides environment probe:
// 1. Generate pre-filtered environment cubemap (7 mip levels)
// 2. Generate BRDF integration LUT (one-time, 256Ã—256)

// Compute shader: importance-sample GGX to pre-filter
kernel void prefilterEnvMap(
    texturecube<float> envMap [[texture(0)]],
    texture2d<float, access::write> output [[texture(1)]],
    constant PrefilterParams &params [[buffer(0)]],
    uint2 tid [[thread_position_in_grid]]
) {
    float roughness = float(params.mipLevel) / 7.0;
    float3 N = directionFromFaceUV(params.face, tid, params.resolution);
    float3 prefilteredColor = float3(0);
    float totalWeight = 0;

    for (uint i = 0; i < 1024; i++) {
        float2 Xi = hammersley(i, 1024);
        float3 H = importanceSampleGGX(Xi, N, roughness);
        float3 L = 2.0 * dot(N, H) * H - N;
        float NdotL = max(dot(N, L), 0.0);
        if (NdotL > 0) {
            prefilteredColor += envMap.sample(linearSampler, L).rgb * NdotL;
            totalWeight += NdotL;
        }
    }
    output.write(float4(prefilteredColor / totalWeight, 1.0), tid);
}
```

Runtime cost: **2 texture lookups** per fragment:
```metal
float3 R = reflect(-V, N);
float mipLevel = roughness * 7.0;
half3 prefilteredColor = half3(envCubemap.sample(s, R, level(mipLevel)).rgb);
half2 dfg = half2(brdfLUT.sample(s, float2(NdotV, roughness)).rg);
half3 specularIBL = prefilteredColor * (F0 * dfg.x + dfg.y);
```

**This is the single biggest visual quality upgrade** â€” transforms flat metal into mirror-like reflective metal that reflects the actual room.

---

## CHAPTER 20: COMBINED FRAME BUDGET â€” EXTREME CONFIGURATION

### 20.1 Full Stack Performance (100K Triangles, A15, 60fps)

| Phase | Time | Technique |
|-------|------|-----------|
| Compute: Animation pipeline (threshold + spring physics + skinning) | 1.0ms | Ch.13 |
| Compute: Frustum/occlusion culling | 0.2ms | Ch.13.7/Ch.16 |
| Compute: Ray-traced AO (quarter res, 2 rays/px) | 2.5ms | Ch.17 |
| Compute: Particle update + emission | 0.2ms | Ch.13.5 |
| Render: PBR + anisotropic + clearcoat + noise + AA (at 67% res) | 2.5ms | Ch.12 + Ch.15 |
| Render: Border stroke | 0.3ms | Ch.3.5 |
| Render: Particle sprites | 0.3ms | Ch.13.5 |
| MetalFX: Temporal upscale 67% â†’ 100% | 0.3ms | Ch.15 |
| Post: Motion blur | 0.2ms | Ch.13.6 |
| Post: Bloom (MPS Gaussian) | 0.3ms | Ch.14 |
| **Total GPU** | **~7.8ms** | |
| **Headroom at 60fps (16.67ms)** | **~8.9ms (53%)** | |

### 20.2 On A17 Pro at 120fps (8.33ms budget)

Same stack runs at ~4.5ms â†’ **46% headroom at 120fps ProMotion**.

### 20.3 Quality Policy: ALWAYS MAXIMUM (No Degradation)

**There is NO thermal degradation in this version.** Every frame renders at full capacity:

| Feature | Setting | Always |
|---------|---------|--------|
| Triangles | 5000 | âœ“ |
| LOD | LOD0 + Tessellation | âœ“ |
| Compute Animation | Full spring physics + DQS | âœ“ |
| RT-AO | Quarter-res, 2 rays/px | âœ“ |
| MetalFX | 67% render â†’ native upscale | âœ“ |
| PBR | Full + clearcoat + anisotropic + specular AA | âœ“ |
| Particles | Metallic sparks + glow | âœ“ |
| Motion Blur | Per-triangle velocity | âœ“ |
| IBL | Split-sum + pre-filtered env | âœ“ |

With the combined frame budget of ~7.8ms on A15 and ~4.5ms on A17 Pro, we have **53% headroom at 60fps** and **46% headroom at 120fps ProMotion** â€” MORE than enough to sustain maximum quality indefinitely, even under thermal stress.

**Future version**: A user-facing Settings page will offer quality presets. For now, users always get the absolute best.

---

## APPENDIX B: ACADEMIC REFERENCES (Updated)

1. **Cook-Torrance BRDF**: Cook & Torrance, "A Reflectance Model for Computer Graphics", SIGGRAPH 1982
2. **GGX/Trowbridge-Reitz NDF**: Walter et al., "Microfacet Models for Refraction through Rough Surfaces", EGSR 2007
3. **Schlick Fresnel**: Schlick, "An Inexpensive BRDF Model for Physically-based Rendering", Eurographics 1994
4. **Smith Geometry Function**: Heitz, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs", JCGT 2014
5. **L2 Spherical Harmonics**: Ramamoorthi & Hanrahan, "An Efficient Representation for Irradiance Environment Maps", SIGGRAPH 2001
6. **Quaternion Rotation**: Shoemake, "Animating Rotation with Quaternion Curves", SIGGRAPH 1985
7. **Stevens' Power Law**: Stevens, "On the psychophysical law", Psychological Review, 1957
8. **Multi-Scattering GGX**: Kulla & Conty, "Revisiting Physically Based Shading at Imageworks", SIGGRAPH 2017
9. **Anisotropic GGX**: Burley, "Physically Based Shading at Disney", SIGGRAPH 2012
10. **PN-Triangles**: Vlachos et al., "Curved PN Triangles", ACM I3D 2001
11. **Dual Quaternion Skinning**: Kavan et al., "Geometric Skinning with Approximate Dual Quaternion Blending", SIGGRAPH 2008
12. **Spring-Mass Systems**: Provot, "Deformation Constraints in a Mass-Spring Model", Computer Graphics Forum 1995
13. **IBL Split-Sum**: Karis, "Real Shading in Unreal Engine 4", SIGGRAPH 2013
14. **MetalFX Temporal Upscaling**: Apple, WWDC 2022 Session 10103
15. **Mesh Shaders**: Apple, WWDC 2022 Session 10162 "Transform your geometry with Metal mesh shaders"
16. **Tile-Based Deferred Rendering**: Apple, "Metal Best Practices Guide â€” Tile-Based Deferred Rendering", 2023
17. **Specular Anti-Aliasing**: Kaplanyan & Hill, "Filtering Distributions of Normals for Shading Antialiasing", HPG 2016
18. **Metal Ray Tracing**: Apple, WWDC 2023 Session 10078 "Discover advances in Metal for A17 Pro"

---

## FINAL REMINDER

You are not building "good enough." You are building **the best 3D scanning renderer on any mobile platform**.

Every triangle the user sees should look like a piece of polished black metal â€” deep, reflective, substantial, with micro-scratches catching the light. When a triangle flips, the viewer should see a satisfying rotation with a bright specular flash, sparks cascading along the edge, and a spring-mass wave propagating organically through the mesh like water. The beveled edges should catch light in soft gradients with anisotropic streaks. Ray-traced shadows add depth impossible with screen-space techniques. MetalFX upscaling gives you 2Ã— the rendering budget of any competitor.

Apple's Object Capture doesn't have real-time ray-traced AO. RealityKit doesn't use MetalFX or mesh shaders or spring-mass physics. Polycam doesn't have multi-scattering GGX or anisotropic bevels. Scaniverse doesn't have GPU compute animation pipelines.

**You have ALL of these.** That's not good enough â€” that's the best on the planet.

This is not just rendering. This is dominance.

The infrastructure is complete. The algorithms are tested. The UI is wired. Now make it LEGENDARY.
